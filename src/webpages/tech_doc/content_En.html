
<html>
<head>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="stylesheet" type="text/css" href="/webpages/tech_doc/style_top_footer.css">
    <link rel="stylesheet" type="text/css" href="/webpages/tech_doc/contentstyle.css">
    <link rel="shortcut icon" href="/webpages/homepage/coin.png" type="image/x-icon" /> 
    <title>Learning Page</title>
    
    
    <link href="/webpages/tech_doc/prism.css" rel="stylesheet" />
</head>
<body translate="yes">
    
    <div id="Top_Bar">
        
        <div id="Content">
            <h1 id="company_name"> 
                <span id="logo_1">
                    Magic Fan Made
                </span>
                   Technical Documentation
            </h1>
    
            <span id="split_top">
                |
            </span>
            <div id="nagvigation_bar">

            </div>
    
            
        </div>
        <!-- 右上角创建一个按钮，点击进入 /webpages/tech_doc/content.html -->
        <a href="/tech_doc/zh" style="position: absolute; top: 10px; right: 10px; font-size: 24px; font-weight: bold; text-align: center; text-shadow: 0 0 10px orange; text-decoration: none; background-color: #f0f0f0; padding: 10px 20px; border-radius: 10px; color: #ff4500; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);">Chinese</a>
        <!-- <div id="Path">
            <a href="/homepage">home</a>
             / 
            <a href="/content" class="main_path">learn</a>

        </div> -->
        
    </div>
</div>
    <div id="Black_Top_Bar">
      
    </div>

    <div id="main_body">
        <ul id="title_list">
        <!-- <li >
            <a class="link active" href="#pseudocode" onclick="scrollToTarget(event)">Player</a>
            <div class="sublinks">
                <a class="sublink" href="#styles" onclick="scrollToTarget(event)">Player Attributes</a>
                <a class="sublink" href="#variables" onclick="scrollToTarget(event)">Player Functions</a>
                <a class="sublink" href="#start" onclick="scrollToTarget(event)">Start/Finish</a>
                <a class="sublink" href="#testP" onclick="scrollToTarget(event)">Test yourself</a>
            </div>
            
        </li>
        <li>
            <a class="link"  href="#sets&arrays" onclick="scrollToTarget(event)">Room</a>
            <div class="sublinks">
                <a class="sublink" href="#setOp" onclick="scrollToTarget(event)">Set operations</a>
                <a class="sublink" href="#prodSets" onclick="scrollToTarget(event)">Product of sets</a>
                <a class="sublink" href="#arrays" onclick="scrollToTarget(event)">Higher dimensional arrays</a>
                <a class="sublink" href="#testS" onclick="scrollToTarget(event)">Test yourself</a>
          
            </div>
        </li>
        <li>
            <a class="link" href="#problemsolving" onclick="scrollToTarget(event)">Card</a>
            <div class="sublinks">
                <a class="sublink" href="#abstraction" onclick="scrollToTarget(event)">Abstraction</a>
                <a class="sublink" href="#decomposition" onclick="scrollToTarget(event)">Decomposition</a>
                <a class="sublink" href="#evaluation" onclick="scrollToTarget(event)">Evaluation</a>
                <a class="sublink" href="#testPs" onclick="scrollToTarget(event)">Test yourself</a>
            </div>
        </li>
        <li>
            <a class="link" href="#graph" onclick="scrollToTarget(event)">Creature</a>
            <div class="sublinks">
                <a class="sublink" href="#typesOfGraphs" onclick="scrollToTarget(event)">Types of graphs</a>
                <a class="sublink" href="#graphRep" onclick="scrollToTarget(event)">Graph representation</a>
                <a class="sublink" href="#eulerian" onclick="scrollToTarget(event)">Eulerian paths</a>
                <a class="sublink" href="#testG" onclick="scrollToTarget(event)">Test yourself</a>
            </div>
        </li> -->
      </ul>


<div id = "pseudocode" class="title_content">
    <div class = "top">
        <h1>Player Class</h2> 
    </div>
        <div id = "styles"></div>
        <h2>Player Class Attributes</h2> 
        
        <pre><code class="lang-python">
class Player:



def __init__(self,name:str,decks_detail:str,action_stroe:actions.List_Action_Processor) -> None:
    self.name=name

    self.opponent:Player#opponent player

    #the life of player
    self.ini_life:int=20
    self.life:int=20

    #list of Graveyard
    self.graveyard:list[Card]=[]

    #list of Library
    self.library:list[Card]=[]

    #list of Battlefield
    self.battlefield:list[Creature]=[]

    #land area
    self.land_area:list[Land]=[]

    #hand area
    self.hand:list[Card]=[]

    #exile area
    self.exile_area:list[Card]=[]

    #mana cost [colorless, blue,white,black,red,green]
    self.mana={"colorless":0,"U":0,"W":0,"B":0,"R":0,"G":0}

    #counter dict like number of turns, number of cards used
    self.counter_dict:dict={}
    self.counter_dict["lands_summon_max"]=1


    #Aura pool
    self.aura_pool:list[Card]=[]


    
         </code></pre>
        <h3>Opponent Player</h3> 
        <pre><code class="lang-python">
self.opponent:Player
        </code></pre>
        <p>This attribute stores the opponent player, the type is also Player</p>
        <h3>Player's Life</h3> 
        <pre><code class="lang-python">
self.ini_life:int=20
self.life:int=20
        </code></pre>

        <p>ini_life stores the upper limit of life. For example, if you use a healing card, the restored life will not exceed this limit</p>
        <p>life stores the player's current life. If a card wants to check the player's life, it can use this attribute to check. However, when adding or subtracting life, this attribute cannot be used directly. If you need to add or subtract life, you can use
          <a class="link_in_content" href="#setOp" onclick="scrollToTarget(event)">await Card.attact_to_object(player,power,color,type_missile)</a>
          or
          <a class="link_in_content" href="#setOp" onclick="scrollToTarget(event)">await Card.cure_to_object(player,power,color,type_missile)</a>
        </p>


        <h3>Graveyard</h3> 
        <pre><code class="lang-python">
self.graveyard:list[Card]=[]
        </code></pre>
        <p>This attribute is a list class, and the class stores cards. It stores all the cards that have moved into the graveyard, such as creatures that have died or spells that have been cast. You can call this to traverse each card. If you want to add a card to the library, you cannot use append, you need to call
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(card,"graveyard")</a>
        </p>

        <h3>Library</h3> 
        <pre><code class="lang-python">
self.library:list[Card]=[]
        </code></pre>
        <p>This attribute is a list class, and the class stores cards. It is the library, storing all the cards that have not been drawn. You can call this to traverse each card. If you want to add a card to the library, you cannot use append, you need to call
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(card,"library")</a>
          . If you need to draw a card, you need to call
          <a class="link_in_content" href="#draw_card" onclick="scrollToTarget(event)">Player.draw_card(number of cards)</a>
          .
        </p>

        <h3>Battlefield</h3> 
        <pre><code class="lang-python">
self.battlefield:list[Creature]=[]
        </code></pre>
        <p>This attribute is a list class, and the class stores Creatures. It stores the creature cards played by the player. You can call this to traverse each card. If you want to add a card to the library, you cannot use append, you need to call
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(card,"battlefield")</a>
        </p>

        <h3>Land Area</h3> 
        <pre><code class="lang-python">
self.land_area:list[Land]=[]
        </code></pre>
        <p>This attribute is a list class, and the class stores Lands. It stores the land cards played by the player. You can call this to traverse each card. If you want to add a card to the library, you cannot use append, you need to call
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(card,"land_area")</a>
        </p>

        <h3>Hand</h3> 
        <pre><code class="lang-python">
self.hand:list[Card]=[]
        </code></pre>
        <p>This attribute is a list class, and the class stores cards. It stores the player's hand cards. You can call this to traverse each card. If you want to add a card to the library, you cannot use append, you need to call
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(card,"hand")</a>
        </p>

        <h3>Exile Area</h3> 
        <pre><code class="lang-python">
self.exile_area:list[Card]=[]
        </code></pre>
        <p>This attribute is a list class, and the class stores cards. It stores the exiled cards. You can call this to traverse each card. If you want to add a card to the library, you cannot use append, you need to call
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(card,"exile_area")</a>
        </p>


        <h3>Mana</h3> 
        <pre><code class="lang-python">
self.mana={"colorless":0,"U":0,"W":0,"B":0,"R":0,"G":0}
        </code></pre>

        <table>
          <thead>
              <tr>
                  <th>Key</th>
                  <th>Description</th>
                  
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>colorless</td>
                  <td>This mana can be used for any color</td>
                  
              </tr>
              <tr>
                  <td>U</td>
                  <td>Blue mana</td>
                  
              </tr>
              <tr>
                  <td>W</td>
                  <td>White mana</td>
                  
              </tr>
              <tr>
                <td>B</td>
                <td>Black mana</td>
                
              </tr>
              <tr>
                  <td>R</td>
                  <td>Red mana</td>
                  
              </tr>
              <tr>
                <td>G</td>
                <td>Green mana</td>
                
            </tr>
          </tbody>
      </table>
        <p>
          
        </p>

        <h3>Aura</h3> 
        <pre><code class="lang-python">
self.aura_pool:list[Card]=[]
        </code></pre>
        <p>Currently not developed
          
        </p>

        <h3>Flag</h3> 
        <pre><code class="lang-python">
self.flag_dict:dict={}
        </code></pre>
        <p>This can be used to store all flags related to the player
          
        </p>


        



        <div id = "variables"></div>
        <h2>Player Functions</h2>
        <h3>Flag Functions</h3> 
        <pre><code class="lang-python">
get_flag(self,flag_name:str)->bool
        </code></pre>
        <p>
          This function is used for marking.
          For example: there is a card called Twin 1, and another called Twin 2. Their function is that when they die, if both Twin 1 and Twin 2 are dead, a 10/10 monster will be summoned.
          The code can be written like this.
          When writing the death effect, check if this flag is true. If both are true, the monster can be summoned.
          <pre><code class="lang-python">
#Death effect of Twin 1
async def when_die(self,player: "Player" = None, opponent: "Player" = None):
    player.flag_dict["Twin 1"]=True
    if self.get_flag("Twin 1") and self.get_flag("Twin 2"):
        new_creature=Monster(player)
        player.append_card(new_creature,"battlefield")
        
           </code></pre>
           <pre><code class="lang-python">
#Death effect of Twin 2
async def when_die(self,player: "Player" = None, opponent: "Player" = None):
    player.flag_dict["Twin 2"]=True
    if self.get_flag("Twin 1") and self.get_flag("Twin 2"):
        new_creature=Monster(player)
        player.append_card(new_creature,"battlefield")
        
             </code></pre>
        </p>



        
        <div id="counter-dict-player"></div>  
        <h3>Counter Dict Functions</h3> 
        <pre><code class="lang-python">
add_counter_dict(self,key:str,number:int)->None
set_counter_dict(self,key:str,number:int)->None
get_counter_from_dict(self,key:str)->int
        </code></pre>
        <p>
          This function is used for counting.
          For example: there is a card called Bouncing Bunny. When it enters the battlefield, every time you play a Bouncing Bunny, it gets +2/+2.
          The code can be written like this.
          When writing the death effect, check the "Bouncing Bunny Count" key. Use this to give it a buff.
          <pre><code class="lang-python">          
@select_object("",1)
async def when_enter_battlefield(self, player: "Player" = None, opponent: "Player" = None,selected_object:tuple['Card']=()):# when creature enter battlefield
    for time in range(player.get_counter_from_dict("Bouncing Bunny Count")):#Get the value in "Bouncing Bunny Count"
        buff=StateBuff(self,2,2)
        self.gain_buff(buff,self)
    player.add_counter_dict("Bouncing Bunny Count",1)
           </code></pre>
          player.set_counter_dict("test1",3) means setting the value in "test1" to 3 (at this time the value of test1 is 3)<br>
          player.add_counter_dict("test1",1) means adding 1 to the value in "test1" (at this time the value of test1 is 4)<br>
          player.get_counter_from_dict("test1") will get 4
        </p>

        
        <div id="draw_card"></div>
        <h3>Draw Card</h3> 
        <pre><code class="lang-python">
draw_card(self,number:int)
        </code></pre>
        <p>
          This function is used to draw cards. The number parameter is the number of cards to draw. For example, the death effect of a card is to draw two cards.
          <pre><code class="lang-python">
#Death effect
async def when_die(self,player: "Player" = None, opponent: "Player" = None):
    player.draw_card(2)
        
           </code></pre>
           
        </p>

        <h3>Check if Dead</h3> 
        <pre><code class="lang-python">
async def check_dead(self)->bool:
        </code></pre>
        <p>
          This function checks if the player is dead. If the player is dead, it returns True.
          
           
        </p>
        <div id="append_card"></div>
        <h3>Append/Remove Card</h3> 
        <pre><code class="lang-python">
def append_card(self,card:Card,type:str):
def remove_card(self,card:Card,type:str):
        </code></pre>
        <p>
          This function is used to place a card into an area or remove it from an area.
          <br><br>
          <table>
            <thead>
                <tr>
                    <th>type</th>
                    <th>Description</th>
                    
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>battlefield</td>
                    <td>
                      Battlefield, creatures enter this area after being played. You can use this function to summon creatures.
                      
                    </td>
                    
                </tr>
                <tr>
                    <td>hand</td>
                    <td>Hand, you can use this to place a card into your hand, such as discovering a card.
                      However, removing a card from the hand should not be used.
                    </td>
                    
                </tr>
                <tr>
                    <td>land_area</td>
                    <td>Land area, some cards can also summon lands from the library, so this function will be used.</td>
                    
                </tr>
                <tr>
                  <td>graveyard</td>
                  <td>Graveyard, this will be rarely used. If you want to discard a card, you can use
                    <a class="link_in_content" href="#discard" onclick="scrollToTarget(event)">Player.discard(card)</a>
                  </td>
                  
                </tr>
                <tr>
                    <td>library</td>
                    <td>Library, you can discover a card from the library and place it into your hand.</td>
                    
                </tr>
                <tr>
                  <td>exile_area</td>
                  <td>Exile area, you can exile a card or retrieve a card from the exile area.</td>
                  
              </tr>
            </tbody>
        </table>
          
           
        </p>

        <h3>Check if Mana Cost is Sufficient</h3> 
        <pre><code class="lang-python">
def check_can_use(self,cost:dict)->tuple[bool]:
        </code></pre>
        <p>
          It checks if the player can afford the mana cost. The input parameter is the mana cost, for example, checking if 3 green and 2 red can be paid.
          <pre><code class="lang-python">
cost={"colorless":0,"U":0,"W":0,"B":0,"R":1,"G":3}
result=player.check_can_use(cost)
          </code></pre>
          It returns (boolean,land_store). If boolean is true, land_store stores the lands that can be used to pay.
        </p>

        <h3>Generate and Consume Mana</h3> 
        <pre><code class="lang-python">
async def generate_and_consume_mana(self,lands,cost,card:"Card"):
        </code></pre>
        <p>
          lands are the lands used to generate mana, cost is the mana to be consumed, card is the card that consumes the mana.<br>
          Combine generate mana and consume mana into one. This function first generates mana and then consumes it.<br>
          If you want to consume 2 blue and 3 green mana, you can do this:
          <pre><code class="lang-python">
cost={"colorless":0,"U":2,"W":0,"B":0,"R":0,"G":3}
result=player.check_can_use(cost)
if result[0]:
    await player.generate_and_consume_mana(result[1],cost,self)
          </code></pre>

          
           
        </p>
        <div id="discard"></div>
        <h3>Discard</h3> 
        <pre><code class="lang-python">
def discard(self,card:"Card"):
        </code></pre>
        <p>
          If a card's effect is to discard a card, or to randomly discard a card, you can use this function.
          The input parameter is the card to be discarded.
        </p>




        <h3>Get Specific Type of Cards</h3> 
        <pre><code class="lang-python">
def get_cards_by_pos_type(self,position:str,card_type:tuple["Creature|Land|Sorcery|Instant"]):
        </code></pre>
        <p>
          This function can get specific types of cards. If you want to get all the creature cards in the graveyard:
          <pre><code class="lang-python">
cards=Player.get_cards_by_pos_type("get_cards_by_pos_type",Creature)
          </code></pre>
          <br>
          position: same as
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">append_card's type</a>
          <br>
          
          <br>
          <table>
            <thead>
                <tr>
                    <th>card_type</th>
                    <th>Description</th>
                    
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Creature</td>
                    <td>
                      Creature type, note that this is a type, not a string.
                      
                    </td>
                    
                </tr>
                <tr>
                    <td>Land</td>
                    <td>Land type, note that this is a type, not a string.
                    </td>
                    
                </tr>
                <tr>
                    <td>Sorcery</td>
                    <td>Sorcery type, note that this is a type, not a string.</td>
                    
                </tr>
                <tr>
                  <td>Instant</td>
                  <td>Instant type, note that this is a type, not a string.
                    
                  </td>
                  
                </tr>
                
            </tbody>
        </table>
        </p>

        <div id = "start"></div>
        <h1>Card Class</h1> 
        <h2>Card Attributes</h2>
        <pre><code class="lang-python">
class Card:

    def __init__(self,player) -> None:
        self.player:"Player"=player
        self.name:str=""
        self.flag_dict:dict={}

        self.buffs:list[Buff]=[]

        #counter dict like number of turns, number of cards used
        self.counter_dict:dict={}
        
        #self.keyword_list:list=[]
        self.type:str
        
        #card detail for js
        self.mana_cost:str #Card's cost
        self.color:str #Card's color
        self.type_card:str #Card's type
        self.rarity:str #Card's rarity
        self.content:str #Card's description
        </code></pre>

        <h3>Card Player Ownership</h3>
        <pre><code class="lang-python">
self.player:"Player"=player
        </code></pre>
        <p>
          This indicates the player to whom the card belongs.
        </p>

        <h3>Card Name</h3>
        <pre><code class="lang-python">
self.name:str=""
        </code></pre>

        <h3>Card Special Effects</h3>
        <pre><code class="lang-python">
self.flag_dict:dict={}
        </code></pre>
        <p>
          This represents some effects of the card, such as lifelink or flying.
        </p>
        <table>
          <thead>
              <tr>
                  <th>Special Effect</th>
                  <th>Description</th>
                  
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>reach</td>
                  <td>
                    This effect allows the creature to block flying units.
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>Trample</td>
                  <td>When attacking and destroying a creature, the excess damage will be dealt to the hero.
                  </td>
                  
              </tr>
              <tr>
                  <td>flying</td>
                  <td>When a creature with this effect attacks, it can only be blocked by creatures with flying or reach, otherwise it cannot be blocked.</td>
                  
              </tr>
              <tr>
                <td>haste</td>
                <td>Can attack or block immediately in the turn it is summoned.
                  
                </td>
                
              </tr>
              <tr>
                <td>summoning_sickness</td>
                <td>Cannot attack in the turn it is summoned.
                  
                </td>
                
              </tr>
              <tr>
                <td>Flash</td>
                <td>This card can be played at any time.
                  
                </td>
                
              </tr>
              <tr>
                <td>lifelink</td>
                <td>Lifelink, when dealing damage to a character, it will heal the hero.
                  
                </td>
                
              </tr>
              <tr>
                <td>Vigilance</td>
                <td>Vigilance, creatures with vigilance do not tap when they attack.
                  
                </td>
                
              </tr>
              <tr>
                <td>Double strike</td>
                <td>Allows the creature to attack twice.
                  
                </td>
                
              </tr>
              <tr>
                <td>Menace</td>
                <td>This creature can't be blocked except by two or more creatures.
                  
                </td>
                
              </tr>
              <tr>
                <td>Hexproof</td>
                <td>This creature can't be the target of spells or abilities your opponents control.
                </td>
                
              </tr>
              
              
          </tbody>
      </table>
      <p>
        If you want to create a creature card with the lifelink effect.
      </p>

      <pre><code class="lang-python">
class Aetherweaver(Creature):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Aetherweaver"
        self.live:int=2
        self.power:int=2
        self.actual_live:int=2
        self.actual_power:int=2

        self.type_creature:str="Human Wizard"
        self.type:str="Creature"

        self.mana_cost:str="3U"
        self.color:str="blue"
        self.type_card:str="Human Wizard"
        self.rarity:str="Mythic Rare"
        self.content:str="When Aetherweaver enters the battlefield, you may return target artifact or enchantment from your graveyard to your hand."
        self.image_path:str="cards/creature/Aetherweaver/image.jpg"

        self.flag_dict["lifelink"]=True

      </code></pre>





        <h3>Buff Storage</h3>
        <pre><code class="lang-python">
self.buffs:list[Buff]=[]
        </code></pre>
        <p>
          This is used to store buffs. If you want to store a buff, you can call
          <a class="link_in_content" href="#gain_buff" onclick="scrollToTarget(event)">Card.gain_buff(buff, card that gives the buff)</a>

        </p>

        <h3>Card Counters</h3>
        <pre><code class="lang-python">
self.counter_dict:dict={}
        </code></pre>
        <p>
          This is used for counting, similar to
          <a class="link_in_content" href="#counter-dict-player" onclick="scrollToTarget(event)">player.counter_dict</a>

        </p>

        <h3>Card Type</h3>
        <pre><code class="lang-python">
self.type:str
        </code></pre>
        <table>
          <thead>
              <tr>
                  <th>Type</th>
                  <th>Description</th>
                  
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>Creature</td>
                  <td>
                    Creature type
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>Instant</td>
                  <td>Instant card
                  </td>
                  
              </tr>
              <tr>
                  <td>Land</td>
                  <td>Land card</td>
                  
              </tr>
              <tr>
                <td>Sorcery</td>
                <td>Sorcery card
                  
                </td>
                
              </tr>
              
              
              
          </tbody>
      </table>
        

        <h3>Card Color</h3>
        <pre><code class="lang-python">
self.color:str
        </code></pre>
        <table>
          <thead>
              <tr>
                  <th>Color</th>
                  <th>Description</th>
                  
              </tr>
          </thead>
          <tbody>
                <tr>
                  <td>colorless</td>
                  <td>
                    No color type, the card's background will be gray.
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>blue</td>
                  <td>
                    Ocean, the card's background is blue.
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>gold</td>
                  <td>Sky, the card's background is white.
                  </td>
                  
              </tr>
              <tr>
                  <td>red</td>
                  <td>Volcano, the card's background is red.</td>
                  
              </tr>
              <tr>
                <td>green</td>
                <td>Forest, the card's background is green.
                  
                </td>
                
              </tr>
              <tr>
                <td>black</td>
                <td>Swamp, the card's background is black.
                  
                </td>
                
              </tr>
              
              
              
          </tbody>

      </table>
      <h3>Card Subtype</h3>
        <pre><code class="lang-python">
self.type_card:str
        </code></pre>
        <p>This is similar to type, but more specific for creatures, such as human, elemental demon, etc. Currently, there is no good way to subdivide these.</p>

      <h3>Card Rarity</h3>
      <pre><code class="lang-python">
self.rarity:str
      </code></pre>
      <table>
        <thead>
            <tr>
                <th>Rarity</th>
                <th>Description</th>
                
            </tr>
        </thead>
        <tbody>
              <tr>
                <td>Mythic Rare</td>
                <td>
                  Legendary
                  
                </td>
                
            </tr>
            <tr>
                <td>Rare</td>
                <td>
                  Epic
                  
                </td>
                
            </tr>
            <tr>
                <td>Uncommon</td>
                <td>Rare
                </td>
                
            </tr>
            <tr>
                <td>Common</td>
                <td>Common</td>
                
            </tr>
            
            
            
            
        </tbody>

    </table>


    <h2>Card Functions</h2> 
    <h3>Get Cost</h3>
      <pre><code class="lang-python">
@property
def cost(self)->dict[int]:# colorless,red, green, blue,black,white
    return self.calculate_cost()

      </code></pre>
      <p>If you only need to read, just call Card.cost to get it.</p>

      <h3>When Damage is Done</h3>
      <pre><code class="lang-python">
async def when_harm_is_done(self,card:Union["Creature","Player"],value:int,player: "Player" = None, opponent: "Player" = None):#when damage is done OK
      </code></pre>
      <p>When a card deals damage, this function is called. The card is the object that takes damage, which can be a card or a hero, value is the amount of damage dealt, player is the player who owns this card.</p>
      <p>If you want to add new features, for example, a sorcery card deals 2 damage to a character, and when the damage is done, if the hero takes damage, it deals 1 damage to all enemy minions.</p>

      <pre><code class="lang-python">
class Example(Sorcery):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Example"

        self.type:str="Sorcery"

        self.mana_cost:str="1W"
        self.color:str="gold"
        self.type_card:str="Sorcery"
        self.rarity:str="Uncommon"
        self.content:str=""
        self.image_path:str="cards/sorcery/Angelic Blessing/image.jpg"

    @select_object("all_roles",1)
    async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
        if selected_object:
            await self.attact_to_object(selected_object[0],2,"rgba(0, 0, 0, 0.9)","Missile_Hit")

    async def when_harm_is_done(self,card:Union["Creature","Player"],value:int,player: "Player" = None, opponent: "Player" = None):
        value=await super().when_harm_is_done(card, value, player, opponent)
        if isinstance(card,Player):
            for creature in opponent.battlefield:
                await self.attact_to_object(creature,1,"rgba(0, 0, 0, 0.9)","Missile_Hit")
        return value
      </code></pre>

      <div id="missile_type"></div>
      <h3>Deal Damage, Heal Character</h3>
      <pre><code class="lang-python">
async def attact_to_object(self,object:Union["Creature","Player"],power:int,color:str,type_missile:str):# it won't get hurt object can be card or player
async def cure_to_object(self,object:Union["Creature","Player"],power:int,color:str,type_missile:str):# it won't get hurt
      </code></pre>
      <p>If you want to deal damage or heal a character, you can call this function.</p><br>
      <p>The first parameter object is the target of the damage, the second is the amount of damage, the third is the color of the missile, using "rgba(0, 0, 0, 0.9)", and the fourth is the type of missile.</p>
      <table>
        <thead>
            <tr>
                <th>type_missile</th>
                <th>Description (this can also be customized, requires js)</th>
                
            </tr>
        </thead>
        <tbody>
              <tr>
                <td>Missile_Hit</td>
                <td>
                  This is the most common missile effect.
                  
                </td>
                
            </tr>
            <tr>
                <td>Cure</td>
                <td>
                  This missile will twist twice before hitting.
                  
                </td>
                
            </tr>
            <tr>
                <td>High_Missile</td>
                <td>This missile will fly higher.
                </td>
                
            </tr>
            
            
            
            
        </tbody>

    </table>

      <div id="select_step"></div>
      <h3>Select Card</h3>
      <pre><code class="lang-python">
async def selection_step(self, player: "Player" = None, opponent: "Player" = None,selection_random:bool=False)->list:# when playing a card, this function is called to send card options to the user, the return item must be an array
      </code></pre>
      <p>When playing a card, this function is called to send card options to the user, the return item must be an array. For example, I want to send the user an option to choose whether to pay one red mana or not.</p>

      <pre><code class="lang-python">
class Example(Sorcery):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Example"

        self.type:str="Sorcery"

        self.mana_cost:str="1W"
        self.color:str="gold"
        self.type_card:str="Sorcery"
        self.rarity:str="Uncommon"
        self.content:str=""
        self.image_path:str=""

    @select_object("",1)
    async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
        if selected_object and selected_object[0].content!="Do nothing":
            cost={"colorless":0,"U":0,"W":0,"B":0,"R":1,"G":0}
            result=player.check_can_use(cost)
            if result[0]:
                await player.generate_and_consume_mana(result[1],cost,self)

    async def selection_step(self, player: "Player" = None, opponent: "Player" = None,selection_random:bool=False):
        card1=self.create_selection("Pay R",1)
        card2=self.create_selection("Do nothing",2)
        card=await player.send_selection_cards([selection1,selection2],selection_random)
        
        if card!="cancel" and card.selection_index==1 :
            if  (player.battlefield or opponent.battlefield):
                creature=await send_select_request(self,self.select_range,1,selection_random)
                if creature!="cancel":
                    return creature
                else:
                    return ["cancel"]
            return [selection2]
            
        return [card]
        
      </code></pre>

      <h3>When the Card is Discarded</h3>
      <pre><code class="lang-python">
async def when_discard(self,player: "Player" = None, opponent: "Player" = None):#when the card is discarded
      </code></pre>
      <p>When the card is discarded, this function is called. For example, when the card is discarded, it summons two minions.</p>


      <h3>When a Creature Dies</h3>
      <pre><code class="lang-python">
def when_a_creature_die(self,creature:"Creature",player: "Player" = None, opponent: "Player" = None):#when a creature dies (put a dead creature parameter)
      </code></pre>
      <p>When a creature dies, this function is called. For example, each time a creature dies, the damage increases by 1.</p>
      <pre><code class="lang-python">
def when_a_creature_die(self,creature:"Creature",player: "Player" = None, opponent: "Player" = None):#when a creature dies (put a dead creature parameter)
    self.add_counter_dict("power",1)
      </code></pre>

      <h3>When an Object is Hurt</h3>
      <pre><code class="lang-python">
def when_an_object_hert(self,object,player: "Player" = None, opponent: "Player" = None):#when an object (card or character) is hurt
      </code></pre>
      <p>When an object is hurt, this function is called. For example, each time a creature is hurt, the damage increases by 1. You can first determine if the object is a creature, then increase the attack.</p>


      <h3>When a Creature is Killed</h3>
      <pre><code class="lang-python">
def when_kill_creature(self,card:"Creature",player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>When a creature is killed, this function is called. The card is the killed creature.</p>

      <h3>When the Turn Starts</h3>
      <pre><code class="lang-python">
def when_start_turn(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>When the turn starts, this function is called. For example, draw a card at the start of the turn.</p>


      <h3>Aura Function</h3>
      <pre><code class="lang-python">
def aura(self,player: "Player" = None, opponent: "Player" = None):
      </code></pre>
      <p>This function is still under development.</p>

      <h3>Create Selection</h3>
      <pre><code class="lang-python">
def create_selection(self,content:str,index:int):#create a selection, the image and name are the same, but type_card and content are the selection content
      </code></pre>
      <p>This function returns a selection, which can be used with
        <a class="link_in_content" href="#select_step" onclick="scrollToTarget(event)">Card.selection_step()</a>.
        The first parameter is the description of the selection, the second parameter is the index of the selection.
        The content of the returned selection is the first parameter. The type_card of the selection is "Selection {index}".
      </p>

      <h3>Scry</h3>
      <pre><code class="lang-python">
async def Scry(self,player:'Player',opponent:'Player',times:int):
      </code></pre>
      <p>This function allows the player to look at the top times cards of the library, put the selected cards on top of the library, and the rest on the bottom of the library.
        
      </p>

      <h3>When Gaining a Buff</h3>
      <pre><code class="lang-python">
def when_gain_buff(self,player: "Player" = None, opponent: "Player" = None,buff:Buff=None,card:'Card'=None):#when gaining a +1+1 buff OK
      </code></pre>
      <p>This function is called when gaining a buff.
        
      </p>

      <h3>When Losing a Buff</h3>
      <pre><code class="lang-python">
def when_loss_buff(self,player: "Player" = None, opponent: "Player" = None,buff:Buff=None,card:'Card'=None):#when losing a +1+1 buff OK
      </code></pre>
      <p>This function is called when losing a buff.
        
      </p>

      <div id="gain_buff"></div>
      <h3>Gain Buff</h3>
      <pre><code class="lang-python">
def gain_buff(self,buff,card):
      </code></pre>
      <p>This function is called to gain a buff. For example, to give yourself a +1+1 buff, the card is the card that gives this card the buff.
      <pre><code class="lang-python">
buff=StateBuff(self,self,1,1)
self.gain_buff(buff,self)
        </code></pre>
        
      </p>


      <h3>Lose Buff</h3>
      <pre><code class="lang-python">
def loss_buff(self,buff,card):#card is the card that gives this card the buff
      </code></pre>
      <p>This function is called to lose a buff. For example, to lose a +1+1 buff, the card is the card that makes this card lose the buff.
        <pre><code class="lang-python">
self.loss_buff(buff,self)
        </code></pre>
      </p>

      <h1>Creature Class</h1>
      <pre><code class="lang-python">
class Creature(Card):

    def __init__(self,player) -> None:
        super().__init__(player)
        self.live:int
        self.power:int

        self.actual_live:int
        self.actual_power:int
        
        self.type_creature:str
       </code></pre>
      <h2>Creature Attributes</h2>
      <h3>Original Attack/Health</h3>
      <pre><code class="lang-python">
self.live:int
self.power:int
      </code></pre>
      <p>
      These two attributes are the upper limit of the creature's attributes. If the creature heals, it cannot exceed the upper limit. Some cards can also try to increase the upper limit.
      </p>
      <h3>Attack/Health</h3>
      <pre><code class="lang-python">
self.live:int
self.power:int
      </code></pre>
      <p>When the creature takes damage, it will reduce the health in this attribute.</p>

      <h2>Creature Functions</h2>
      <h3>View Creature Attributes</h3>
      <pre><code class="lang-python">
@property
def state(self):
    state=self.calculate_state()
    return state
      </code></pre>
      <p>This can be used to view the creature's attributes. Generally, this is used instead of directly viewing self.live, etc.</p>

      <h3>Calculate Creature Attributes</h3>
      <pre><code class="lang-python">
def calculate_state(self):
    return (self.actual_power,self.actual_live)
      </code></pre>
      <p>This function is important. It is used to calculate attributes because the obtained attributes are not only the internal self.actual_power, self.actual_live. There may also be buffs, or there may be special creatures, such as a creature whose attack power is equal to its health value.
      </p>
      <pre><code class="lang-python">
def calculate_state(self):
    power,live=super().calculate_state()
    return (live,live)
      </code></pre>

      <div id="when_enter_battlefield"></div>
      <h3>When the Creature Enters the Battlefield</h3>
      <pre><code class="lang-python">
@select_object("",1)
async def when_enter_battlefield(self, player: "Player" = None, opponent: "Player" = None,selected_object:tuple['Card']=()):# when creature enters the battlefield. selection_random=true when user does not select, it will select randomly
      </code></pre>
      <p>This function is used frequently. @select_object("",1) is used to select a character. "" means no selection, 1 means select once, and selected_object will return a tuple containing the selected card. The following table explains the selection range.

        <table>
          <thead>
              <tr>
                  <th>select_object</th>
                  <th>Description</th>
                  
              </tr>
          </thead>
          <tbody>
                <tr>
                  <td>'all_roles'</td>
                  <td>
                    The selection range includes enemy hero, my hero, enemy creatures, my creatures.
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>'opponent_roles'</td>
                  <td>
                    The selection range includes enemy hero, enemy creatures.
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>'your_roles'</td>
                  <td>The selection range includes my hero, my creatures.
                  </td>
                  
              </tr>
              <tr>
                <td>'all_creatures'</td>
                <td>The selection range includes enemy creatures, my creatures.
                </td>
                
              </tr>
              <tr>
                <td>'opponent_creatures'</td>
                <td>The selection range includes enemy creatures.
                </td>
                
              </tr>
              <tr>
                <td>'your_creatures'</td>
                <td>The selection range includes my creatures.
                </td>
                
              </tr>
              <tr>
                <td>'all_lands'</td>
                <td>The selection range includes enemy lands, my lands.
                </td>
                
              </tr>
              <tr>
                <td>'opponent_lands'</td>
                <td>The selection range includes enemy lands.
                </td>
                
              </tr>
              <tr>
                <td>'your_lands'</td>
                <td>The selection range includes my lands.
                </td>
                
              </tr>
              <tr>
                <td>''</td>
                <td>No selection.
                </td>
                
              </tr>
              
              
              
              
          </tbody>
  
      </table>
      When the creature enters the battlefield, this function is called.
      </p>

      <h3>When the Creature Dies</h3>
      <pre><code class="lang-python">
async def when_die(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
      When the creature dies, this function is called.
      </p>


      <h3>When the Turn Starts</h3>
      <pre><code class="lang-python">
def when_start_turn(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        When the turn starts, this function is called.
      </p>


      <h3>When the Turn Ends</h3>
      <pre><code class="lang-python">
def when_end_turn(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        
        When the turn ends, this function is called.
      </p>

      <h3>When the Turn Ends</h3>
      <pre><code class="lang-python">
def when_end_turn(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        
        When the turn ends, this function is called.
      </p>


      <h3>When Hurt</h3>
      <pre><code class="lang-python">
def when_hurt(self,card:"Creature",value:int,player: "Player" = None, opponent: "Player" = None):#when hurt OK
      </code></pre>
      <p>
        When two creatures collide and take damage, this function is called. The card is the creature that deals the damage.
      </p>

      <h3>When Healed</h3>
      <pre><code class="lang-python">
def when_being_treated(self,card:"Creature",value:int,player: "Player" = None, opponent: "Player" = None):#when healed OK
      </code></pre>
      <p>
        When healed, this function is called.
      </p>

      <h3>When Becoming an Attacker</h3>
      <pre><code class="lang-python">
def when_become_attacker(self,player: "Player" = None, opponent: "Player" = None):# OK
      </code></pre>
      <p>
        When becoming an attacker, this function is called.
      </p>

      <h3>When Becoming a Defender</h3>
      <pre><code class="lang-python">
def when_become_defender(self,player: "Player" = None, opponent: "Player" = None):# OK
      </code></pre>
      <p>
        When becoming a defender, this function is called.
      </p>

      <h3>When Killing a Creature</h3>
      <pre><code class="lang-python">
def when_kill_creature(self,card:"Creature",player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        When killing a creature, this function is called.
      </p>


      <h3>When Starting an Attack</h3>
      <pre><code class="lang-python">
def when_start_attcak(self,card:Union["Creature","Player"],player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        When starting an attack, this function is called. This is called when the attack is about to start, and it is different from becoming an attacker. The card is the defender or the hero being attacked.
      </p>

      <h3>When Starting to Defend</h3>
      <pre><code class="lang-python">
def when_start_defend(self,card:"Creature",player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        When starting to defend, this function is called. This is called when the defense is about to start, and it is different from becoming a defender. The card is the attacker.
      </p>

      <h3>Tap and Untap, Creature</h3>
      <pre><code class="lang-python">
def tap(self):
def untap(self):
      </code></pre>
      <p>
        If you need to tap or untap, you can call Card.tap() or Card.untap().
      </p>
      <pre><code class="lang-python">
self.get_flag("tap")
      </code></pre>
      <p>If you want to check if it is tapped, just call get_flag.</p>



      <h1>Land Class</h1>
      <pre><code class="lang-python">
class Land(Card):
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.flag_dict:dict={}
      </code></pre>

      <h2>Land Functions</h2>
      <h3>Check if Usable</h3>
      <pre><code class="lang-python">
def check_can_use(self,player:'Player')->tuple[bool, str]:# check whether the user can use this card, bool and reason
      </code></pre>
      <p>Other types of checks are used to check if the cost is enough. This will check if the player has already used a land.</p>


      <h3>Generate Mana</h3>
      <pre><code class="lang-python">
def generate_mana(self)->dict:
      </code></pre>
      <p>This will return a dictionary containing mana. For example, if you want this land card to generate 2 green and 2 red mana.</p>
      <pre><code class="lang-python">
def generate_mana(self)->dict:
    return {"R":2,"G":2}
      </code></pre>


      <h3>When Entering the Battlefield - Land</h3>
      <pre><code class="lang-python">
@select_object("",1)
async def when_enter_battlefield(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):
      </code></pre>
      <p>
        The effect can refer to
        <a class="link_in_content" href="#when_enter_battlefield" onclick="scrollToTarget(event)">Creature.when_enter_battlefield()</a>
      </p>

      <h3>When the Card is Clicked</h3>
      <pre><code class="lang-python">
async def when_clicked(self,player:'Player'=None,opponent:'Player'=None):#when the land card is clicked, it taps, some generate mana, some have other abilities. Activated abilities: abilities that can be used at any time by paying the cost, usually in the format "[cost]: [effect]".
      </code></pre>
      <p>
        When the land is clicked, some effects will be triggered. If you want to modify it, you can do it like this.
      </p>
      <pre><code class="lang-python">
async def when_clicked(self,player:'Player'=None,opponent:'Player'=None):#when the land card is clicked, it taps, some generate mana, some have other abilities. Activated abilities: abilities that can be used at any time by paying the cost, usually in the format "[cost]: [effect]".
    if not self.get_flag("tap"):
        #write some effects here
        self.tap()
        return True
    else:
        return False
      </code></pre>



      <h1>Sorcery Class</h1>
      <pre><code class="lang-python">
class Sorcery(Card):
    
    def __init__(self,player) -> None:
        super().__init__(player)
      </code></pre>
      
      <h2>Sorcery Functions</h2>
      <h3>When Sorcery is Played</h3>
      <pre><code class="lang-python">
@select_object("",1)
async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
    
      </code></pre>
      <p>
        The effect can refer to
        <a class="link_in_content" href="#when_enter_battlefield" onclick="scrollToTarget(event)">Creature.when_enter_battlefield()</a>
        Very similar
      </p>

      <h1>Instant Class</h1>
      <pre><code class="lang-python">
class Instant(Card):
    
    def __init__(self,player) -> None:
        super().__init__(player)
      </code></pre>
      
      <h2>Instant Functions</h2>
      <h3>When Instant is Played</h3>
      <pre><code class="lang-python">
@select_object("",1)
async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
    
      </code></pre>
      <p>
        The effect can refer to
        <a class="link_in_content" href="#when_enter_battlefield" onclick="scrollToTarget(event)">Creature.when_enter_battlefield()</a>
        Very similar
      </p>



      <h1>Buff Class</h1>
      <pre><code class="lang-python">
class Buff:
    
    def __init__(self,card:"Card",selected_card:"Card") -> None:
        self.card=card#which card this buff belongs to
        self.card_type:str=""#which type this buff is used on
        self.content:str=""#description of the buff
        self.buff_missile="Missile_Hit"
        self.color_missile="rgba(203, 203, 203, 0.9)"
        self.buff_name="Buff"
        self.selected_card=selected_card
      </code></pre>
      
      <h2>Buff Attributes</h2>
      <h3>Buff.Card</h3>
      <pre><code class="lang-python">
self.card=card#which card this buff belongs to
      </code></pre>
      <p>Stores the card that is given the buff</p>

      <h3>Buff Type</h3>
      <pre><code class="lang-python">
self.card_type:str=""#which type this buff is used on
      </code></pre>
      <p>Stores the type of the buff, for example, a buff that adds attribute values (+1+1) is called State, you can also define it yourself</p>

      <h3>Buff Content</h3>
      <pre><code class="lang-python">
self.content:str=""#description of the buff
      </code></pre>
      <p>Used to describe the effect of the buff</p>

      <h3>Buff Missile</h3>
      <pre><code class="lang-python">
self.buff_missile="Missile_Hit"
self.color_missile="rgba(203, 203, 203, 0.9)"
      </code></pre>
      <p>self.buff_missile stores the type of missile, you can check this
        <a class="link_in_content" href="#missile_type" onclick="scrollToTarget(event)">table</a>.
        self.color_missile stores the color of the missile, in the form of "rgba(0, 0,0 , 0)"
      </p>

      <h3>Buff Name</h3>
      <pre><code class="lang-python">
self.buff_name=""
      </code></pre>
      <p>Stores the name of the buff, you can name it yourself</p>

      <h3>Buff Selected Object</h3>
      <pre><code class="lang-python">
self.selected_card=selected_card
      </code></pre>
      <p>Stores the card that is affected by the buff</p>


      <h2>Buff Functions</h2>

      <h3>Buff Change Card Function</h3>
      <pre><code class="lang-python">
def change_function(self,card:"Creature"):
      </code></pre>
      <p>This is used to reflect the effect of the buff, you can dynamically modify a function of the Card class to reflect this buff. For example, let a minion get a buff, this buff will take effect when it dies</p>
      <pre><code class="lang-python">
def change_function(self,card:"Creature"):
    previews_func=card.when_die
    async def when_die(self_card,player,opponent):
        await previews_func(player,opponent)
        #write the function after death here
    card.when_die = types.MethodType(when_die, card)
      </code></pre>

      <h1>Card File Layout</h1>
      <h2>py File Layout</h2>
      All custom card files will be placed in src/pycards
      <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Path</th>
                
            </tr>
        </thead>
        <tbody>
              <tr>
                <td>creature</td>
                <td>
                  src/pycards/creature
                  
                </td>
                
            </tr>
            <tr>
                <td>instant</td>
                <td>
                  src/pycards/Instant
                  
                </td>
                
            </tr>
            <tr>
                <td>land</td>
                <td>src/pycards/land
                </td>
                
            </tr>
            <tr>
              <td>sorcery</td>
              <td>src/pycards/sorcery
              </td>
              
            </tr>

        </tbody>

    </table>

      <h2>js File Layout</h2>
      All custom card files will be placed in src/cards
      <table>
        <thead>
            <tr>
                <th>Type</th>
                <th>Path</th>
                
            </tr>
        </thead>
        <tbody>
              <tr>
                <td>creature</td>
                <td>
                  src/cards/creature
                  
                </td>
                
            </tr>
            <tr>
                <td>instant</td>
                <td>
                  src/cards/Instant
                  
                </td>
                
            </tr>
            <tr>
                <td>land</td>
                <td>src/cards/land
                </td>
                
            </tr>
            <tr>
              <td>sorcery</td>
              <td>src/cards/sorcery
              </td>
              
            </tr>

        </tbody>

    </table>

      <h1>Example of Creating a Card - Creature</h1>
      <h2>Creature - Example 1</h2>
      If you want to create a creature card, named Xuanpei, with attributes 7/2, mana cost 3UU, legendary rarity, the effect is to select a creature, get +1+1, and give a random friendly creature +1+1 when it dies
      <pre><code class="lang-python">


from game.buffs import StateBuff

class Xuanpei(Creature):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Xuanpei"
        self.live:int=2
        self.power:int=7
        self.actual_live:int=2
        self.actual_power:int=7

        self.type_creature:str="Human"
        self.type:str="Creature"

        self.mana_cost:str="3UU"
        self.color:str="blue"
        self.type_card:str="Human"
        self.rarity:str="Mythic Rare"
        self.content:str="When Xuanpei enters the battlefield, select a creature and +1+1,when die randomly select your creature and +1+1"
        self.image_path:str="cards/creature/Xuanpei/image.jpg"
        
    @select_object("all_creatures",1)
    async def when_enter_battlefield(self, player: "Player" = None, opponent: "Player" = None,selected_object:tuple['Card']=()):# when creature enter battlefield
        if selected_object:
            buff=StateBuff(self,selected_object[0],1,1)
            selected_object[0].gain_buff(buff,self)

     async def when_die(self,player: "Player" = None, opponent: "Player" = None):#OK
        if player.battlefield:
            card=random.choice(player.battlefield)
            buff=StateBuff(self,card,1,1)
            card.gain_buff(buff,self)


      </code></pre>
      <h1>Example of Creating a Card - Land</h1>
      <h2>Land - Example 1</h2>
      If you want to create a land card, named Ji, the function is to draw a card when clicked, it is blue
      <pre><code class="lang-python">
class Ji(Land):


    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Ji"

        self.type:str="Land"

        self.mana_cost:str=""
        self.color:str="blue"
        self.type_card:str="Land"
        self.rarity:str="Rare"
        self.content:str="it will draw a card instead of generate mana"
        self.image_path:str="cards/land/Elysian Grove/image.jpg"

    async def when_clicked(self,player:'Player'=None,opponent:'Player'=None):#when the land card is clicked, it taps, some generate mana, some have other abilities. Activated abilities: abilities that can be used at any time by paying the cost, usually in the format "[cost]: [effect]".
        if not self.get_flag("tap"):
            player.draw_card(1)
            self.tap()
            return True
        else:
            return False
        </code></pre>
        <h2>Land - Example 2</h2>
      If you want to create a land card, named Ni, the function is to generate 3 black mana when clicked, and deal 3 damage to your hero when it enters the battlefield
      <pre><code class="lang-python">
class Ni(Land):


    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Ni"

        self.type:str="Land"

        self.mana_cost:str=""
        self.color:str="black"
        self.type_card:str="Land"
        self.rarity:str="Rare"
        self.content:str="generate 3 mana , when enter battlefield deal 3 damage to your player"
        self.image_path:str="cards/land/Elysian Grove/image.jpg"

    def generate_mana(self)->dict:
        return {"B":3}

    @select_object("",1)
    async def when_enter_battlefield(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):
        await self.attact_to_object(player,3,"rgba(0, 0, 0, 0.9)","Missile_Hit")
    
      </code></pre>
      <h1>Example of Creating a Card - Sorcery</h1>
      <h2>Sorcery - Example 1</h2>
      If you want to create a sorcery card named Tai, with mana cost 3G, it summons two treants, and then gives each friendly minion a deathrattle to summon a treant, you can do it like this
      <pre><code class="lang-python">

from game.buffs import Buff
from game.type_cards.creature import Creature



class Tai_Summon_Die_Tree(Buff):
    def __init__(self,card:"Card",selected_card:"Card") -> None:
        super().__init__(card,selected_card)
        self.card=card#which card this buff belongs to
        self.content:str="Summon one 1/1 tree"#description of the buff
        self.buff_name=f"{card.name}"

    def change_function(self,card:"Creature"):
        previews_func=card.when_die
        async def when_die(self_card,player,opponent):
            await previews_func(player,opponent)
            creature_tree=Tai_Tree(card.player)
            player.append_card(creature_tree,"battlefield")
        card.when_die = types.MethodType(when_die, card)
    

class Tai(Sorcery):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Tai"

        self.type:str="Sorcery"

        self.mana_cost:str="3G"
        self.color:str="green"
        self.type_card:str="Sorcery"
        self.rarity:str="Uncommon"
        self.content:str="..."
        self.image_path:str="cards/sorcery/Angelic Blessing/image.jpg"
    @select_object("",1)
    async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
        for i in range(2):
            creature_tree=Tai_Tree(self.player)
            player.append_card(creature_tree,"battlefield")
        for card in player.battlefield:
            buff=Tai_Summon_Die_Tree(self,card)
            card.gain_buff(buff,self)
        
    
class Tai_Tree(Creature):
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Tree man"
        self.live:int=1
        self.power:int=1
        self.actual_live:int=1
        self.actual_power:int=1

        self.type_creature:str="Creature"
        self.type:str="Creature"

        self.mana_cost:str="1"
        self.color:str="green"
        self.type_card:str="Creature"
        self.rarity:str="Uncommon"
        self.content:str=""
        self.image_path:str="cards/sorcery/Angelic Blessing/image.jpg"
    

      </code></pre>

      <!-- <h2>Sorcery - Example 2</h2> -->
      
      <h1>Example of Creating a Card - Instant</h1>
      <h2>Instant - Example 1</h2>
      If you want to create an instant card named Mei, with mana cost 3W, choose to either heal your hero for 10 points or scry 10
      <pre><code class="lang-python">
class Mei(Instant):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Mei"

        self.type:str="Instant"

        self.mana_cost:str="3W"
        self.color:str="gold"
        self.type_card:str="Instant"
        self.rarity:str="Mythic Rare"
        self.content:str="..."
        self.image_path:str="cards/Instant/Arcane Inferno/image.jpg"

    @select_object("",1)
    async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):
        if selected_object:
            if selected_object[0].content=="Cure 10":
                await self.cure_to_object(player,10,"rgba(255, 255, 255, 0.9)","Missile_Hit")
            elif selected_object[0].content=="Scry 10":
                await self.Scry(self,player,opponent,10):


    async def selection_step(self, player: "Player" = None, opponent: "Player" = None,selection_random:bool=False):
        selection1=self.create_selection("Cure 10",1)
        selection2=self.create_selection("Scry 10",2)

        card=await player.send_selection_cards([selection1,selection2],selection_random)
            
        return [card]

      </code></pre>
      <!-- <h2>Instant - Example 2</h2> -->
    </div>
        





      
     

  </div>
  <script src="/webpages/tech_doc/create_dir.js"></script>
  <script src="/webpages/tech_doc/top_footer.js"></script>
  <script src="/webpages/tech_doc/subtitle.js"></script>
  <script src="/webpages/tech_doc/prism.js"></script>
  
</body>

</html>