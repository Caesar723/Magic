
<html>
<head>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="stylesheet" type="text/css" href="webpages/tech_doc/style_top_footer.css">
    <link rel="stylesheet" type="text/css" href="webpages/tech_doc/contentstyle.css">
    <link rel="shortcut icon" href="webpages/homepage/coin.png" type="image/x-icon" /> 
    <title>Learning Page</title>
    
    
    <link href="webpages/tech_doc/prism.css" rel="stylesheet" />
</head>
<body translate="yes">
    
    <div id="Top_Bar">
        
        <div id="Content">
            <h1 id="company_name"> 
                <span id="logo_1">
                    Magic Fan Made
                </span>
                   技术文档
            </h1>
    
            <span id="split_top">
                |
            </span>
            <div id="nagvigation_bar">

            </div>
    
            
        </div>
        <!-- <div id="Path">
            <a href="/homepage">home</a>
             / 
            <a href="/content" class="main_path">learn</a>

        </div> -->
        
    </div>
</div>
    <div id="Black_Top_Bar">
    </div>

    <div id="main_body">
        <ul id="title_list">
        <!-- <li >
            <a class="link active" href="#pseudocode" onclick="scrollToTarget(event)">Player</a>
            <div class="sublinks">
                <a class="sublink" href="#styles" onclick="scrollToTarget(event)">Player 属性</a>
                <a class="sublink" href="#variables" onclick="scrollToTarget(event)">Player 函数</a>
                <a class="sublink" href="#start" onclick="scrollToTarget(event)">Start/Finish</a>
                <a class="sublink" href="#testP" onclick="scrollToTarget(event)">Test yourself</a>
            </div>
            
        </li>
        <li>
            <a class="link"  href="#sets&arrays" onclick="scrollToTarget(event)">Room</a>
            <div class="sublinks">
                <a class="sublink" href="#setOp" onclick="scrollToTarget(event)">Set operations</a>
                <a class="sublink" href="#prodSets" onclick="scrollToTarget(event)">Product of sets</a>
                <a class="sublink" href="#arrays" onclick="scrollToTarget(event)">Higher dimensional arrays</a>
                <a class="sublink" href="#testS" onclick="scrollToTarget(event)">Test yourself</a>
          
            </div>
        </li>
        <li>
            <a class="link" href="#problemsolving" onclick="scrollToTarget(event)">Card</a>
            <div class="sublinks">
                <a class="sublink" href="#abstraction" onclick="scrollToTarget(event)">Abstraction</a>
                <a class="sublink" href="#decomposition" onclick="scrollToTarget(event)">Decomposition</a>
                <a class="sublink" href="#evaluation" onclick="scrollToTarget(event)">Evaluation</a>
                <a class="sublink" href="#testPs" onclick="scrollToTarget(event)">Test yourself</a>
            </div>
        </li>
        <li>
            <a class="link" href="#graph" onclick="scrollToTarget(event)">Creature</a>
            <div class="sublinks">
                <a class="sublink" href="#typesOfGraphs" onclick="scrollToTarget(event)">Types of graphs</a>
                <a class="sublink" href="#graphRep" onclick="scrollToTarget(event)">Graph representation</a>
                <a class="sublink" href="#eulerian" onclick="scrollToTarget(event)">Eulerian paths</a>
                <a class="sublink" href="#testG" onclick="scrollToTarget(event)">Test yourself</a>
            </div>
        </li> -->
      </ul>


<div id = "pseudocode" class="title_content">
    <div class = "top">
        <h1>Player 类</h2> 
    </div>
        <div id = "styles"></div>
        <h2>Player 类所有属性</h2> 
        
        <pre><code class="lang-python">
class Player:



def __init__(self,name:str,decks_detail:str,action_stroe:actions.List_Action_Processor) -> None:
    self.name=name

    self.opponent:Player#opponent player

    #the life of player
    self.ini_life:int=20
    self.life:int=20

    #list of Graveyard 墓地 这里可以包含所有的卡牌而不只是随从
    self.graveyard:list[Card]=[]

    #list of Library牌库
    self.library:list[Card]=[]

    #list of Battlefield 场地
    self.battlefield:list[Creature]=[]

    #land area
    self.land_area:list[Land]=[]

    #hand area
    self.hand:list[Card]=[]

    #exile area
    self.exile_area:list[Card]=[]

    #mana cost [colorless, blue,white,black,red,green]
    self.mana={"colorless":0,"U":0,"W":0,"B":0,"R":0,"G":0}

    #counter dict like number of turns, number of cards used
    self.counter_dict:dict={}
    self.counter_dict["lands_summon_max"]=1


    #Aura光环 pool
    self.aura_pool:list[Card]=[]


    
         </code></pre>
        <h3>敌方玩家</h3> 
        <pre><code class="lang-python">
self.opponent:Player
        </code></pre>
        <p>这个属性是存储敌方玩家，类型也是Player</p>
        <h3>玩家的血量</h3> 
        <pre><code class="lang-python">
self.ini_life:int=20
self.life:int=20
        </code></pre>

        <p>ini_life 存储的是血量的上限，比如你使用了回血的卡牌，回复的血量是不会超过这个上限的</p>
        <p>life 存储的是玩家目前的血量，如果有一张卡牌想要查看我方玩家的血量，就可以使用次属性查看，但是扣血或者加血的时候不可以直接使用此属性。如果需要加血或者扣血可以使用
          <a class="link_in_content" href="#setOp" onclick="scrollToTarget(event)">await Card.attact_to_object(player,power,color,type_missile)</a>
          或者是
          <a class="link_in_content" href="#setOp" onclick="scrollToTarget(event)">await Card.cure_to_object(player,power,color,type_missile)</a>
        </p>


        <h3>墓地</h3> 
        <pre><code class="lang-python">
self.graveyard:list[Card]=[]
        </code></pre>
        <p>这个属性是list的类，类里存储的是card。存储所有移进墓地的卡牌，比如死亡后的随从，或者是打出的法术牌，可以调用这个来遍历每一张卡牌。如果想要往牌库里加牌，不可以使用append，需要调用
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(卡牌,"graveyard")</a>
        </p>

        <h3>牌库</h3> 
        <pre><code class="lang-python">
self.library:list[Card]=[]
        </code></pre>
        <p>这个属性是list的类，类里存储的是card。是牌库，储存所有没有被抽上来的卡牌，可以调用这个来遍历每一张卡牌。如果想要往牌库里加牌，不可以使用append，需要调用
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(卡牌,"library")</a>
          。如果需要抽牌，需要调用
          <a class="link_in_content" href="#draw_card" onclick="scrollToTarget(event)">Player.draw_card(卡牌的数量)</a>
          。
        </p>

        <h3>战斗场地</h3> 
        <pre><code class="lang-python">
self.battlefield:list[Creature]=[]
        </code></pre>
        <p>这个属性是list的类，类里存储的是Creature。这里存的就是玩家打出的创造物的牌，可以调用这个来遍历每一张卡牌。可以如果想要往牌库里加牌，不可以使用append，需要调用
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(卡牌,"battlefield")</a>
        </p>

        <h3>地池</h3> 
        <pre><code class="lang-python">
self.land_area:list[Land]=[]
        </code></pre>
        <p>这个属性是list的类，类里存储的是Land。这里保存的是玩家打出的地牌。可以调用这个来遍历每一张卡牌。如果想要往牌库里加牌，不可以使用append，需要调用
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(卡牌,"land_area")</a>
        </p>

        <h3>手牌</h3> 
        <pre><code class="lang-python">
self.hand:list[Card]=[]
        </code></pre>
        <p>这个属性是list的类，类里存储的是card。这里保存的是玩家的手牌。可以调用这个来遍历每一张卡牌。如果想要往牌库里加牌，不可以使用append，需要调用
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(卡牌,"hand")</a>
        </p>

        <h3>流放区域</h3> 
        <pre><code class="lang-python">
self.exile_area:list[Card]=[]
        </code></pre>
        <p>这个属性是list的类，类里存储的是card。这里保存的是流放的牌。可以调用这个来遍历每一张卡牌。如果想要往牌库里加牌，不可以使用append，需要调用
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">Player.append_card(卡牌,"exile_area")</a>
        </p>


        <h3>法力值</h3> 
        <pre><code class="lang-python">
self.mana={"colorless":0,"U":0,"W":0,"B":0,"R":0,"G":0}
        </code></pre>

        <table>
          <thead>
              <tr>
                  <th>Key</th>
                  <th>描述</th>
                  
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>colorless</td>
                  <td>这个是法力值代表所有的颜色都可以用</td>
                  
              </tr>
              <tr>
                  <td>U</td>
                  <td>蓝色法力值</td>
                  
              </tr>
              <tr>
                  <td>W</td>
                  <td>白色法力值</td>
                  
              </tr>
              <tr>
                <td>B</td>
                <td>黑色法力值</td>
                
              </tr>
              <tr>
                  <td>R</td>
                  <td>红色法力值</td>
                  
              </tr>
              <tr>
                <td>G</td>
                <td>绿色法力值</td>
                
            </tr>
          </tbody>
      </table>
        <p>
          
        </p>

        <h3>光环</h3> 
        <pre><code class="lang-python">
self.aura_pool:list[Card]=[]
        </code></pre>
        <p>目前还没有开发完成
          
        </p>

        <h3>flag</h3> 
        <pre><code class="lang-python">
self.flag_dict:dict={}
        </code></pre>
        <p>这个可以用来储存所有关于player的flag
          
        </p>


        



        <div id = "variables"></div>
        <h2>Player 的函数</h2>
        <h3>flag 函数</h3> 
        <pre><code class="lang-python">
get_flag(self,flag_name:str)->bool
        </code></pre>
        <p>
          这个函数的作用是可以用来标记。
          举一个例子：有一张卡牌叫双子1，还有一张叫双子2，他们的功能是当死亡时，如果双子1和双子2都死亡了，就会召唤10/10的怪物。
          那么代码就可以这么写。
          在写亡语效果的时候，检查这个flag是不是true，如果两个都是true的情况下，就可以召唤怪物。
          <pre><code class="lang-python">
#双子1的亡语
async def when_die(self,player: "Player" = None, opponent: "Player" = None):
    player.flag_dict["双子1"]=True
    if self.get_flag("双子1") and self.get_flag("双子2"):
        new_creature=怪物(player)
        player.append_card(new_creature,"battlefield")
        
           </code></pre>
           <pre><code class="lang-python">
#双子2的亡语
async def when_die(self,player: "Player" = None, opponent: "Player" = None):
    player.flag_dict["双子2"]=True
    if self.get_flag("双子1") and self.get_flag("双子2"):
        new_creature=怪物(player)
        player.append_card(new_creature,"battlefield")
        
             </code></pre>
        </p>



        
        <div id="counter-dict-player"></div>  
        <h3>counter dict 函数</h3> 
        <pre><code class="lang-python">
add_counter_dict(self,key:str,number:int)->None
set_counter_dict(self,key:str,number:int)->None
get_counter_from_dict(self,key:str)->int
        </code></pre>
        <p>
          这个函数的作用是可以用来计数。
          举一个例子：有一张蹦蹦兔，当他进入场上的时候，你每打出一张蹦蹦兔，就会+2/+2。
          那么代码就可以这么写。
          在写亡语效果的时候，检查这个”蹦蹦兔计数“这个key。根据这个来给它加buff
          <pre><code class="lang-python">          
@select_object("",1)
async def when_enter_battlefield(self, player: "Player" = None, opponent: "Player" = None,selected_object:tuple['Card']=()):# when creature enter battlefield
    for time in range(player.get_counter_from_dict("蹦蹦兔计数")):#代表获取"蹦蹦兔计数"里的值
        buff=StateBuff(self,2,2)
        self.gain_buff(buff,self)
    player.add_counter_dict("蹦蹦兔计数",1)
           </code></pre>
          player.set_counter_dict("test1",3)这个意思就是在把"test1"这个里面的值设置成3(这时候test1的值是3)<br>
          player.add_counter_dict("test1",1)这个意思就是在把"test1"这个里面的值+1(这时候test1的值是4)<br>
          player.get_counter_from_dict("test1")会获取4
        </p>

        
        <div id="draw_card"></div>
        <h3>抽牌</h3> 
        <pre><code class="lang-python">
draw_card(self,number:int)
        </code></pre>
        <p>
          这个函数的作用是抽牌，number参数抽取的数量。比如一张牌的亡语是抽两张牌
          <pre><code class="lang-python">
#亡语
async def when_die(self,player: "Player" = None, opponent: "Player" = None):
    player.draw_card(2)
        
           </code></pre>
           
        </p>

        <h3>检查死亡</h3> 
        <pre><code class="lang-python">
async def check_dead(self)->bool:
        </code></pre>
        <p>
          这个函数的作用是检查玩家是否死亡，如果玩家死亡了会返回True
          
           
        </p>
        <div id="append_card"></div>
        <h3>放入/移除卡牌</h3> 
        <pre><code class="lang-python">
def append_card(self,card:Card,type:str):
def remove_card(self,card:Card,type:str):
        </code></pre>
        <p>
          这个函数的作用将卡牌置入区域中，或者是从区域中移除
          <br><br>
          <table>
            <thead>
                <tr>
                    <th>type</th>
                    <th>描述</th>
                    
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>battlefield</td>
                    <td>
                      场地，creature打出后就会进入这个区域。可以使用此函数来召唤随从
                      
                    </td>
                    
                </tr>
                <tr>
                    <td>hand</td>
                    <td>手牌，你可以使用这个来让一张牌置入到你的手牌，比如发现一张牌。
                      但是移除手牌这个应该不会用到
                    </td>
                    
                </tr>
                <tr>
                    <td>land_area</td>
                    <td>地池，有些卡牌也会从牌库中召唤地之类的，就会用到这个函数</td>
                    
                </tr>
                <tr>
                  <td>graveyard</td>
                  <td>墓地，这个会很少用到，如果想要弃牌，可以使用
                    <a class="link_in_content" href="#discard" onclick="scrollToTarget(event)">Player.discard(卡牌)</a>
                  </td>
                  
                </tr>
                <tr>
                    <td>library</td>
                    <td>牌库，可以从牌库发现一张牌，置入手牌</td>
                    
                </tr>
                <tr>
                  <td>exile_area</td>
                  <td>流放区域，可以把卡牌流放，或者从流放区域里取回卡牌</td>
                  
              </tr>
            </tbody>
        </table>
          
           
        </p>

        <h3>检查法力值消耗是否足够</h3> 
        <pre><code class="lang-python">
def check_can_use(self,cost:dict)->tuple[bool]:
        </code></pre>
        <p>
          它会检查玩家是否支付得起这些法力。输入的参数是法力值，比如检查是否可以支付3绿2红
          <pre><code class="lang-python">
cost={"colorless":0,"U":0,"W":0,"B":0,"R":1,"G":3}
result=player.check_can_use(cost)
          </code></pre>
          它会返回(boolean,land_store),如果boolean是true，land_store就是存了那些可以支付的地牌
        </p>

        <h3>产生并消耗法力值</h3> 
        <pre><code class="lang-python">
async def generate_and_consume_mana(self,lands,cost,card:"Card"):
        </code></pre>
        <p>
          lands是用这些land来产生法力值，cost是要消耗的法力值，card是要消耗这些法力值的卡牌<br>
          把generate mana 和consume mana 合并到一起，这个函数会先阐述法力值，然后再消耗这些法力值。<br>
          如果想要做到消耗2点蓝色，3点绿色法力值，可以这这样做
          <pre><code class="lang-python">
cost={"colorless":0,"U":2,"W":0,"B":0,"R":0,"G":3}
result=player.check_can_use(cost)
if result[0]:
    await player.generate_and_consume_mana(result[1],cost,self)
          </code></pre>

          
           
        </p>
        <div id="discard"></div>
        <h3>弃牌</h3> 
        <pre><code class="lang-python">
def discard(self,card:"Card"):
        </code></pre>
        <p>
          如果有写卡牌的效果是弃牌，或者是随机弃牌，可以使用这个函数。
          输入的参数是需要弃置地牌
        </p>




        <h3>获取特定类型的牌</h3> 
        <pre><code class="lang-python">
def get_cards_by_pos_type(self,position:str,card_type:tuple["Creature|Land|Sorcery|Instant"]):
        </code></pre>
        <p>
          这个函数可以获取特定类型的牌，如果你想要获取墓地里所有的创造物的牌
          <pre><code class="lang-python">
cards=Player.get_cards_by_pos_type("get_cards_by_pos_type",Creature)
          </code></pre>
          <br>
          position：与
          <a class="link_in_content" href="#append_card" onclick="scrollToTarget(event)">append_card的type</a>
          一样<br>
          
          <br>
          <table>
            <thead>
                <tr>
                    <th>card_type</th>
                    <th>描述</th>
                    
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Creature</td>
                    <td>
                      创造物类型，注意，这个是类型而不是字符串
                      
                    </td>
                    
                </tr>
                <tr>
                    <td>Land</td>
                    <td>地类型，注意，这个是类型而不是字符串
                    </td>
                    
                </tr>
                <tr>
                    <td>Sorcery</td>
                    <td>法术类型，注意，这个是类型而不是字符串</td>
                    
                </tr>
                <tr>
                  <td>Instant</td>
                  <td>瞬间类型，注意，这个是类型而不是字符串
                    
                  </td>
                  
                </tr>
                
            </tbody>
        </table>
        </p>

        <div id = "start"></div>
        <h1>Card 类</h1> 
        <h2>Card 属性</h2>
        <pre><code class="lang-python">
class Card:

    def __init__(self,player) -> None:
        self.player:"Player"=player
        self.name:str=""
        self.flag_dict:dict={}

        self.buffs:list[Buff]=[]

        #counter dict like number of turns, number of cards used
        self.counter_dict:dict={}
        
        #self.keyword_list:list=[]
        self.type:str
        
        #card detail for js
        self.mana_cost:str #卡牌的费用
        self.color:str #卡牌的颜色
        self.type_card:str #卡牌的颜色
        self.rarity:str #卡牌的稀有度
        self.content:str #卡牌描述的内容
        </code></pre>

        <h3>Card玩家归属</h3>
        <pre><code class="lang-python">
self.player:"Player"=player
        </code></pre>
        <p>
          这个表明这个卡牌所属的玩家
        </p>

        <h3>卡牌名字</h3>
        <pre><code class="lang-python">
self.name:str=""
        </code></pre>

        <h3>卡牌的特殊效果</h3>
        <pre><code class="lang-python">
self.flag_dict:dict={}
        </code></pre>
        <p>
          这个是卡牌的一些效果，像吸血飞行之类的
        </p>
        <table>
          <thead>
              <tr>
                  <th>特殊效果</th>
                  <th>描述</th>
                  
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>reach</td>
                  <td>
                    这个效果是可以阻挡飞行单位
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>Trample</td>
                  <td>当攻击并消灭了一个创造物时，多余的血量会对英雄造成伤害
                  </td>
                  
              </tr>
              <tr>
                  <td>flying</td>
                  <td>当具有此效果的创造物攻击的时候，只有具有flying或者reach的创造物才可以阻挡，不然无法阻挡</td>
                  
              </tr>
              <tr>
                <td>haste</td>
                <td>在你召唤的那一回合内，可以立即攻击或者阻挡
                  
                </td>
                
              </tr>
              <tr>
                <td>summoning_sickness</td>
                <td>在召唤的那一回合内，创造物不可以攻击
                  
                </td>
                
              </tr>
              <tr>
                <td>Flash</td>
                <td>这张卡可以在任何时候打出
                  
                </td>
                
              </tr>
              <tr>
                <td>lifelink</td>
                <td>吸血，当对一个角色造成伤害是，会对我方英雄回血
                  
                </td>
                
              </tr>
              <tr>
                <td>Vigilance</td>
                <td>警戒，具有警戒能力的生物可以在其攻击时不会横置（即表示疲劳状态）
                  
                </td>
                
              </tr>
              <tr>
                <td>Double strike</td>
                <td>允许创造物攻击两次
                  
                </td>
                
              </tr>
              <tr>
                <td>Menace</td>
                <td>This creature can't be blocked except by two or more creatures.
                  
                </td>
                
              </tr>
              <tr>
                <td>Hexproof</td>
                <td>This creature can't be the target of spells or abilities your opponents control.
                </td>
                
              </tr>
              
              
          </tbody>
      </table>
      <p>
        如果想要创造一张创造物卡牌Creature，并且拥有吸血效果
      </p>

      <pre><code class="lang-python">
class Aetherweaver(Creature):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Aetherweaver"
        self.live:int=2
        self.power:int=2
        self.actual_live:int=2
        self.actual_power:int=2

        self.type_creature:str="Human Wizard"
        self.type:str="Creature"

        self.mana_cost:str="3U"
        self.color:str="blue"
        self.type_card:str="Human Wizard"
        self.rarity:str="Mythic Rare"
        self.content:str="When Aetherweaver enters the battlefield, you may return target artifact or enchantment from your graveyard to your hand."
        self.image_path:str="cards/creature/Aetherweaver/image.jpg"

        self.flag_dict["lifelink"]=True

      </code></pre>





        <h3>buff 储存</h3>
        <pre><code class="lang-python">
self.buffs:list[Buff]=[]
        </code></pre>
        <p>
          这个是用来储存buff的，如果想要储存buff，可以调用
          <a class="link_in_content" href="#gain_buff" onclick="scrollToTarget(event)">Card.gain_buff(buff,给予buff的牌)</a>

        </p>

        <h3>卡牌中的计数器</h3>
        <pre><code class="lang-python">
self.counter_dict:dict={}
        </code></pre>
        <p>
          这个是用来计数的，原理与
          <a class="link_in_content" href="#counter-dict-player" onclick="scrollToTarget(event)">player.counter_dict</a>
          相似

        </p>

        <h3>卡牌类型</h3>
        <pre><code class="lang-python">
self.type:str
        </code></pre>
        <table>
          <thead>
              <tr>
                  <th>type</th>
                  <th>描述</th>
                  
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td>Creature</td>
                  <td>
                    创造物类型
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>Instant</td>
                  <td>瞬间牌
                  </td>
                  
              </tr>
              <tr>
                  <td>Land</td>
                  <td>地牌</td>
                  
              </tr>
              <tr>
                <td>Sorcery</td>
                <td>法术牌
                  
                </td>
                
              </tr>
              
              
              
          </tbody>
      </table>
        

        <h3>卡牌颜色</h3>
        <pre><code class="lang-python">
self.color:str
        </code></pre>
        <table>
          <thead>
              <tr>
                  <th>color</th>
                  <th>描述</th>
                  
              </tr>
          </thead>
          <tbody>
                <tr>
                  <td>colorless</td>
                  <td>
                    没有颜色类型，卡牌的背景会是灰色
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>blue</td>
                  <td>
                    海洋，卡牌的背景是蓝色
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>gold</td>
                  <td>天空，卡牌的背景是白色
                  </td>
                  
              </tr>
              <tr>
                  <td>red</td>
                  <td>火山，卡牌的背景是红色</td>
                  
              </tr>
              <tr>
                <td>green</td>
                <td>森林，卡牌的背景是绿色
                  
                </td>
                
              </tr>
              <tr>
                <td>black</td>
                <td>沼泽，卡牌的背景是黑色
                  
                </td>
                
              </tr>
              
              
              
          </tbody>

      </table>
      <h3>卡牌类型细分</h3>
        <pre><code class="lang-python">
self.type_card:str
        </code></pre>
        <p>这个与type很相似，不同的点就是在creature里，这个会被细分，比如有人类，元素恶魔，但是目前没有很好的戏份这些</p>

      <h3>卡牌稀有度</h3>
      <pre><code class="lang-python">
self.rarity:str
      </code></pre>
      <table>
        <thead>
            <tr>
                <th>color</th>
                <th>描述</th>
                
            </tr>
        </thead>
        <tbody>
              <tr>
                <td>Mythic Rare</td>
                <td>
                  传说
                  
                </td>
                
            </tr>
            <tr>
                <td>Rare</td>
                <td>
                  史诗
                  
                </td>
                
            </tr>
            <tr>
                <td>Uncommon</td>
                <td>稀有
                </td>
                
            </tr>
            <tr>
                <td>Common</td>
                <td>普通</td>
                
            </tr>
            
            
            
            
        </tbody>

    </table>


    <h2>Card 函数</h2> 
    <h3>获取费用</h3>
      <pre><code class="lang-python">
@property
def cost(self)->dict[int]:# colorless,red, green, blue,black,white
    return self.calculate_cost()

      </code></pre>
      <p>如果只需要读取，那就直接调用Card.cost获取。</p>

      <h3>当造成伤害时</h3>
      <pre><code class="lang-python">
async def when_harm_is_done(self,card:Union["Creature","Player"],value:int,player: "Player" = None, opponent: "Player" = None):#当造成伤害时 OK
      </code></pre>
      <p>当一张卡牌造成伤害时，就会调用这个函数。card是对某一个对象造成伤害可以是卡牌也可以是英雄，value是造成伤害的大小，player是这个持有此卡牌的玩家.</p>
      <p>如果想要增加新的功能，比如有一张法术牌,对一个角色造成两点伤害，当造成伤害后，如果是英雄受到伤害那对所有敌方的随从造成一点伤害</p>

      <pre><code class="lang-python">
class Example(Sorcery):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Example"

        self.type:str="Sorcery"

        self.mana_cost:str="1W"
        self.color:str="gold"
        self.type_card:str="Sorcery"
        self.rarity:str="Uncommon"
        self.content:str=""
        self.image_path:str="cards/sorcery/Angelic Blessing/image.jpg"

    @select_object("all_roles",1)
    async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
        if selected_object:
            await self.attact_to_object(selected_object[0],2,"rgba(0, 0, 0, 0.9)","Missile_Hit")

    async def when_harm_is_done(self,card:Union["Creature","Player"],value:int,player: "Player" = None, opponent: "Player" = None):
        value=await super().when_harm_is_done(card, value, player, opponent)
        if isinstance(card,Player):
            for creature in opponent.battlefield:
                await self.attact_to_object(creature,1,"rgba(0, 0, 0, 0.9)","Missile_Hit")
        return value
      </code></pre>

      <div id="missile_type"></div>
      <h3>造成伤害，给角色回血</h3>
      <pre><code class="lang-python">
async def attact_to_object(self,object:Union["Creature","Player"],power:int,color:str,type_missile:str):# it won't get hurt object can be card ot player
async def cure_to_object(self,object:Union["Creature","Player"],power:int,color:str,type_missile:str):# it won't get hurt
      </code></pre>
      <p>如果想要对一个角色造成伤害或者是回血，就可以调用这个函数。</p><br>
      <p>第一个参数object是造成伤害的对象，第二个是造成伤害的值，第三个是弹幕的颜色,使用“rgba(0, 0, 0, 0.9)”,第四个是导弹的类型</p>
      <table>
        <thead>
            <tr>
                <th>type_missile</th>
                <th>描述(这个也可以自己制作，需要用到js)</th>
                
            </tr>
        </thead>
        <tbody>
              <tr>
                <td>Missile_Hit</td>
                <td>
                  这个是最普通的飞弹效果
                  
                </td>
                
            </tr>
            <tr>
                <td>Cure</td>
                <td>
                  这个飞弹会扭两下再击中
                  
                </td>
                
            </tr>
            <tr>
                <td>High_Missile</td>
                <td>这个飞弹会飞的比较高
                </td>
                
            </tr>
            
            
            
            
        </tbody>

    </table>

      <div id="select_step"></div>
      <h3>选择卡牌</h3>
      <pre><code class="lang-python">
async def selection_step(self, player: "Player" = None, opponent: "Player" = None,selection_random:bool=False)->list:# 当打出牌是，会调用此函数，给用户发送卡牌选项,返回项必须是数组
      </code></pre>
      <p>当打出牌时，会调用此函数，给用户发送卡牌选项,返回项必须是数组。比如我想给用户发送个选项，是选择支付一点红色法力值还是不支付。</p>

      <pre><code class="lang-python">
class Example(Sorcery):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Example"

        self.type:str="Sorcery"

        self.mana_cost:str="1W"
        self.color:str="gold"
        self.type_card:str="Sorcery"
        self.rarity:str="Uncommon"
        self.content:str=""
        self.image_path:str=""

    @select_object("",1)
    async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
        if selected_object and selected_object[0].content!="Do nothing":
            cost={"colorless":0,"U":0,"W":0,"B":0,"R":1,"G":0}
            result=player.check_can_use(cost)
            if result[0]:
                await player.generate_and_consume_mana(result[1],cost,self)

    async def selection_step(self, player: "Player" = None, opponent: "Player" = None,selection_random:bool=False):
        card1=self.create_selection("Pay R",1)
        card2=self.create_selection("Do nothing",2)
        card=await player.send_selection_cards([selection1,selection2],selection_random)
        
        if card!="cancel" and card.selection_index==1 :
            if  (player.battlefield or opponent.battlefield):
                creature=await send_select_request(self,self.select_range,1,selection_random)
                if creature!="cancel":
                    return creature
                else:
                    return ["cancel"]
            return [selection2]
            
        return [card]
        
      </code></pre>

      <h3>当该牌被弃置的时候</h3>
      <pre><code class="lang-python">
async def when_discard(self,player: "Player" = None, opponent: "Player" = None):#当卡牌被弃置
      </code></pre>
      <p>当卡牌被弃置时，会调用此函数。比如当卡牌弃置的时候会召唤两只小怪</p>


      <h3>当一个创造物死亡的时候会调用</h3>
      <pre><code class="lang-python">
def when_a_creature_die(self,creature:"Creature",player: "Player" = None, opponent: "Player" = None):#当随从死亡时（放入一个死亡随从的参数）
      </code></pre>
      <p>当一个创造物死亡时，会调用此函数。比如每有一个创造物死亡，伤害就+1</p>
      <pre><code class="lang-python">
def when_a_creature_die(self,creature:"Creature",player: "Player" = None, opponent: "Player" = None):#当随从死亡时（放入一个死亡随从的参数）
    self.add_counter_dict("power",1)
      </code></pre>

      <h3>当一个角色受到伤害的时候调用</h3>
      <pre><code class="lang-python">
def when_an_object_hert(self,object,player: "Player" = None, opponent: "Player" = None):#当一个card or 人物收到伤害，object是card 或者 player
      </code></pre>
      <p>当一个角色受到伤害时，会调用此函数。比如每有一个创造物收到伤害，伤害就+1，可以先判断object是不是创造物，然后加攻击</p>


      <h3>当击杀一个创造物调用</h3>
      <pre><code class="lang-python">
def when_kill_creature(self,card:"Creature",player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>当杀死一个创造物时，会调用此函数。card是杀死的创造物</p>

      <h3>当回合开始时调用</h3>
      <pre><code class="lang-python">
def when_start_turn(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>当回合开始时，会调用此函数。比如回合开始时抽一张牌</p>


      <h3>光环函数</h3>
      <pre><code class="lang-python">
def aura(self,player: "Player" = None, opponent: "Player" = None):
      </code></pre>
      <p>此函数还在开发</p>

      <h3>创建选项</h3>
      <pre><code class="lang-python">
def create_selection(self,content:str,index:int):#生成一个selection，图片和名字是一样的，但是type_card和content是选项内容
      </code></pre>
      <p>这个函数会返回一个选项，可以配合
        <a class="link_in_content" href="#select_step" onclick="scrollToTarget(event)">Card.selection_step()</a>。
        输入的第一个参数选项的描述，第二个参数选项的索引
        返回的选项里selection.content内容就是第一个参数。selection.type_card是“Selection {index}”
      </p>

      <h3>祈祷</h3>
      <pre><code class="lang-python">
async def Scry(self,player:'Player',opponent:'Player',times:int):
      </code></pre>
      <p>这个函数会让玩家从牌库里看前times的的牌，把选中的牌放入牌顶，其余的放在牌底
        
      </p>

      <h3>当获得buff时</h3>
      <pre><code class="lang-python">
def when_gain_buff(self,player: "Player" = None, opponent: "Player" = None,buff:Buff=None,card:'Card'=None):#当获得+1+1的buff时 OK
      </code></pre>
      <p>当获得buff时调用此函数
        
      </p>

      <h3>当失去buff时</h3>
      <pre><code class="lang-python">
def when_loss_buff(self,player: "Player" = None, opponent: "Player" = None,buff:Buff=None,card:'Card'=None):#当获得+1+1的buff时 OK
      </code></pre>
      <p>当失去buff时调用此函数
        
      </p>

      <div id="gain_buff"></div>
      <h3>获得buff</h3>
      <pre><code class="lang-python">
def gain_buff(self,buff,card):
      </code></pre>
      <p>获得buff调用此函数。比如给自己+1+1的buff，card是给这个牌buff的牌
      <pre><code class="lang-python">
buff=StateBuff(self,self,1,1)
self.gain_buff(buff,self)
        </code></pre>
        
      </p>


      <h3>失去buff</h3>
      <pre><code class="lang-python">
def loss_buff(self,buff,card):#card 是给这个牌buff的牌
      </code></pre>
      <p>失去buff调用此函数。比如失去+1+1的buff，card是让这个牌失去buff的牌
        <pre><code class="lang-python">
self.loss_buff(buff,self)
        </code></pre>
      </p>

      <h1>Creature 类</h1>
      <pre><code class="lang-python">
class Creature(Card):

    def __init__(self,player) -> None:
        super().__init__(player)
        self.live:int
        self.power:int

        self.actual_live:int
        self.actual_power:int
        
        self.type_creature:str
       </code></pre>
      <h2>Creature 属性</h2>
      <h3>原始攻击/生命</h3>
      <pre><code class="lang-python">
self.live:int
self.power:int
      </code></pre>
      <p>
      这个两个属性是这个创造物的属性上限，如果这个创造物回血了，那它不能超过给血量上限。有些牌也可以试着提升上限
      </p>
      <h3>攻击/生命</h3>
      <pre><code class="lang-python">
self.live:int
self.power:int
      </code></pre>
      <p>当创造物收到伤害时，就会扣这里面的血</p>

      <h2>Creature 函数</h2>
      <h3>查看创造物属性</h3>
      <pre><code class="lang-python">
@property
def state(self):
    state=self.calculate_state()
    return state
      </code></pre>
      <p>这个可以用来查看创造物属性，一般都会用这个，而不是直接用self.live之类的查看</p>

      <h3>计算创造物属性</h3>
      <pre><code class="lang-python">
def calculate_state(self):
    return (self.actual_power,self.actual_live)
      </code></pre>
      <p>这个函数比较重要，它是用来计算属性的，因为获取的属性不是只有里面的self.actual_power,self.actual_live。还有可能会有buff，或者会有比较特殊的创造物，比如说有一个创造物，它的攻击力等于血量的值
      </p>
      <pre><code class="lang-python">
def calculate_state(self):
    power,live=super().calculate_state()
    return (live,live)
      </code></pre>

      <div id="when_enter_battlefield"></div>
      <h3>当创造物进入场地时</h3>
      <pre><code class="lang-python">
@select_object("",1)
async def when_enter_battlefield(self, player: "Player" = None, opponent: "Player" = None,selected_object:tuple['Card']=()):# when creature enter battlefield . selection_random=true when user not select it will select random
      </code></pre>
      <p>这个函数使用的会比较平凡，@select_object("",1)是用来选择角色的""表示不选择，1表示选择一次，selected_object会返回一个tuple包含了选择的卡牌，以下表格会解释选择的范围。

        <table>
          <thead>
              <tr>
                  <th>select_object</th>
                  <th>描述</th>
                  
              </tr>
          </thead>
          <tbody>
                <tr>
                  <td>'all_roles'</td>
                  <td>
                    选择的范围为，敌方英雄，我方英雄，敌方创造物，我方创造物
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>'opponent_roles'</td>
                  <td>
                    选择的范围为，敌方英雄，敌方创造物
                    
                  </td>
                  
              </tr>
              <tr>
                  <td>'your_roles'</td>
                  <td>选择的范围为，我方英雄，我方创造物
                  </td>
                  
              </tr>
              <tr>
                <td>'all_creatures'</td>
                <td>选择的范围为，敌方创造物，我方创造物
                </td>
                
              </tr>
              <tr>
                <td>'opponent_creatures'</td>
                <td>选择的范围为，敌方创造物
                </td>
                
              </tr>
              <tr>
                <td>'your_creatures'</td>
                <td>选择的范围为，我方创造物
                </td>
                
              </tr>
              <tr>
                <td>'all_lands'</td>
                <td>选择的范围为，敌方地池，我方地池
                </td>
                
              </tr>
              <tr>
                <td>'opponent_lands'</td>
                <td>选择的范围为，敌方地池
                </td>
                
              </tr>
              <tr>
                <td>'your_lands'</td>
                <td>选择的范围为，我方地池
                </td>
                
              </tr>
              <tr>
                <td>''</td>
                <td>不选择
                </td>
                
              </tr>
              
              
              
              
          </tbody>
  
      </table>
      当随从进入场地的时候，就会调用这个函数
      </p>

      <h3>当创造物死亡时</h3>
      <pre><code class="lang-python">
async def when_die(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
      当创造物死亡时，就会调用这个函数
      </p>


      <h3>当回合开始时</h3>
      <pre><code class="lang-python">
def when_start_turn(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        当回合开始时，就会调用这个函数
      </p>


      <h3>当回合结束时</h3>
      <pre><code class="lang-python">
def when_end_turn(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        
        当回合结束时，就会调用这个函数
      </p>

      <h3>当回合结束时</h3>
      <pre><code class="lang-python">
def when_end_turn(self,player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        
        当回合结束时，就会调用这个函数
      </p>


      <h3>当受到伤害时</h3>
      <pre><code class="lang-python">
def when_hurt(self,card:"Creature",value:int,player: "Player" = None, opponent: "Player" = None):#当受到伤害时 OK
      </code></pre>
      <p>
        当两个创造物撞击收到伤害时，就会调用这个函数。card时造成伤害的creature
      </p>

      <h3>当受到治疗时</h3>
      <pre><code class="lang-python">
def when_being_treated(self,card:"Creature",value:int,player: "Player" = None, opponent: "Player" = None):#当受到伤害时 OK
      </code></pre>
      <p>
        当受到治疗时，就会调用这个函数
      </p>

      <h3>当成为攻击者时</h3>
      <pre><code class="lang-python">
def when_become_attacker(self,player: "Player" = None, opponent: "Player" = None):# OK
      </code></pre>
      <p>
        当成为攻击者时，就会调用这个函数
      </p>

      <h3>当成为防御者时</h3>
      <pre><code class="lang-python">
def when_become_defender(self,player: "Player" = None, opponent: "Player" = None):# OK
      </code></pre>
      <p>
        当成为防御者时，就会调用这个函数
      </p>

      <h3>当杀死一个创造物时</h3>
      <pre><code class="lang-python">
def when_kill_creature(self,card:"Creature",player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        当杀死一个创造物时，就会调用这个函数
      </p>


      <h3>当开始攻击时</h3>
      <pre><code class="lang-python">
def when_start_attcak(self,card:Union["Creature","Player"],player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        当开始攻击时，就会调用这个函数，这个是要攻击了才会调用这个函数，和成为攻击者不一样，card是防御者或者是被攻击的英雄。
      </p>

      <h3>当开始防御时</h3>
      <pre><code class="lang-python">
def when_start_defend(self,card:"Creature",player: "Player" = None, opponent: "Player" = None):#OK
      </code></pre>
      <p>
        当开始防御时，就会调用这个函数，这个是要防御了才会调用这个函数，和成为防御者不一样，card是攻击者
      </p>

      <h3>横置与解横置，creature</h3>
      <pre><code class="lang-python">
def tap(self):
def untap(self):
      </code></pre>
      <p>
        如果需要横置，或者是解横置，就可以调用Card.tap()或者Card.untap()
      </p>
      <pre><code class="lang-python">
self.get_flag("tap")
      </code></pre>
      <p>如果想查看是否横置，只要调用get_flag就可以</p>



      <h1>Land 类</h1>
      <pre><code class="lang-python">
class Land(Card):
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.flag_dict:dict={}
      </code></pre>

      <h2>Land 函数</h2>
      <h3>检查是否可用</h3>
      <pre><code class="lang-python">
def check_can_use(self,player:'Player')->tuple[bool, str]:# check whether user can use this card , bool and reason
      </code></pre>
      <p>别的种类的check是用来检查费用是否够，这个会检查玩家是否已经使用过land了</p>


      <h3>产生法力值</h3>
      <pre><code class="lang-python">
def generate_mana(self)->dict:
      </code></pre>
      <p>这个会返回一个diction，里面会包含法力值，比如你这个地牌想要产生2点绿，2点红</p>
      <pre><code class="lang-python">
def generate_mana(self)->dict:
    return {"R":2,"G":2}
      </code></pre>


      <h3>当进入场地——land</h3>
      <pre><code class="lang-python">
@select_object("",1)
async def when_enter_battlefield(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):
      </code></pre>
      <p>
        效果可以参考
        <a class="link_in_content" href="#when_enter_battlefield" onclick="scrollToTarget(event)">Creature.when_enter_battlefield()</a>
      </p>

      <h3>当点击卡牌时</h3>
      <pre><code class="lang-python">
async def when_clicked(self,player:'Player'=None,opponent:'Player'=None):#当地牌被点击时横置，有一些是获得mana，有一些是别的能力   #启动式能力（Activated Abilities）：玩家可以在任何时候支付成本来使用的能力，通常格式为“[成本]：[效果]”。
      </code></pre>
      <p>
        当点击land的时候会出发某些效果，如果像修改的话可以这样
      </p>
      <pre><code class="lang-python">
async def when_clicked(self,player:'Player'=None,opponent:'Player'=None):#当地牌被点击时横置，有一些是获得mana，有一些是别的能力   #启动式能力（Activated Abilities）：玩家可以在任何时候支付成本来使用的能力，通常格式为“[成本]：[效果]”。
    if not self.get_flag("tap"):
        #这里写入某些效果
        self.tap()
        return True
    else:
        return False
      </code></pre>



      <h1>Sorcery 类</h1>
      <pre><code class="lang-python">
class Sorcery(Card):
    
    def __init__(self,player) -> None:
        super().__init__(player)
      </code></pre>
      
      <h2>Sorcery 函数</h2>
      <h3>当打出Sorcery时</h3>
      <pre><code class="lang-python">
@select_object("",1)
async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
    
      </code></pre>
      <p>
        效果可以参考
        <a class="link_in_content" href="#when_enter_battlefield" onclick="scrollToTarget(event)">Creature.when_enter_battlefield()</a>
        非常类似
      </p>

      <h1>Instant 类</h1>
      <pre><code class="lang-python">
class Instant(Card):
    
    def __init__(self,player) -> None:
        super().__init__(player)
      </code></pre>
      
      <h2>Instant 函数</h2>
      <h3>当打出Instant时</h3>
      <pre><code class="lang-python">
@select_object("",1)
async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
    
      </code></pre>
      <p>
        效果可以参考
        <a class="link_in_content" href="#when_enter_battlefield" onclick="scrollToTarget(event)">Creature.when_enter_battlefield()</a>
        非常类似
      </p>



      <h1>Buff 类</h1>
      <pre><code class="lang-python">
class Buff:
    
    def __init__(self,card:"Card",selected_card:"Card") -> None:
        self.card=card#这个buff是属于哪一张卡的
        self.card_type:str=""#这个buff是用在那个类型的
        self.content:str=""#描述buff
        self.buff_missile="Missile_Hit"
        self.color_missile="rgba(203, 203, 203, 0.9)"
        self.buff_name="Buff"
        self.selected_card=selected_card
      </code></pre>
      
      <h2>Buff 属性</h2>
      <h3>Buff.Card</h3>
      <pre><code class="lang-python">
self.card=card#这个buff是属于哪一张卡的
      </code></pre>
      <p>储存是给予buff的卡牌</p>

      <h3>Buff 类型</h3>
      <pre><code class="lang-python">
self.card_type:str=""#这个buff是用在那个类型的
      </code></pre>
      <p>储存的是buff的种类，比如加属性值（+1+1）的就是就是叫State,也可以自己定义</p>

      <h3>Buff 内容</h3>
      <pre><code class="lang-python">
self.content:str=""#描述buff
      </code></pre>
      <p>用于描述buff的效果的</p>

      <h3>Buff 弹幕</h3>
      <pre><code class="lang-python">
self.buff_missile="Missile_Hit"
self.color_missile="rgba(203, 203, 203, 0.9)"
      </code></pre>
      <p>self.buff_missile储存的是弹幕的种类,可以查看此
        <a class="link_in_content" href="#missile_type" onclick="scrollToTarget(event)">表格</a>。
        self.color_missile存的是弹幕的颜色，是"rgba(0, 0,0 , 0)"形式的
      </p>

      <h3>Buff 名字</h3>
      <pre><code class="lang-python">
self.buff_name=""
      </code></pre>
      <p>储存是buff的名字，可以自己取名</p>

      <h3>Buff 选择的对象</h3>
      <pre><code class="lang-python">
self.selected_card=selected_card
      </code></pre>
      <p>储存是受到buff的卡牌</p>


      <h2>Buff 函数</h2>

      <h3>Buff 修改card函数</h3>
      <pre><code class="lang-python">
def change_function(self,card:"Creature"):
      </code></pre>
      <p>这个就是用来体现buff效果的，你可以动态修改Card类的某一个函数来体现这个buff。比如让一个随从获得一个buff，这个buff会再死亡的时候生效</p>
      <pre><code class="lang-python">
def change_function(self,card:"Creature"):
    previews_func=card.when_die
    async def when_die(self_card,player,opponent):
        await previews_func(player,opponent)
        #这里写死亡后的功能
    card.when_die = types.MethodType(when_die, card)
      </code></pre>

      <h1>卡牌文件布局</h1>
      <h2>py文件布局</h2>
      所有的自定义卡牌文件都会放在src/pycards里
      <table>
        <thead>
            <tr>
                <th>类型</th>
                <th>路径</th>
                
            </tr>
        </thead>
        <tbody>
              <tr>
                <td>creature</td>
                <td>
                  src/pycards/creature
                  
                </td>
                
            </tr>
            <tr>
                <td>instant</td>
                <td>
                  src/pycards/Instant
                  
                </td>
                
            </tr>
            <tr>
                <td>land</td>
                <td>src/pycards/land
                </td>
                
            </tr>
            <tr>
              <td>sorcery</td>
              <td>src/pycards/sorcery
              </td>
              
            </tr>

        </tbody>

    </table>

      <h2>js文件布局</h2>
      所有的自定义卡牌文件都会放在src/cards里
      <table>
        <thead>
            <tr>
                <th>类型</th>
                <th>路径</th>
                
            </tr>
        </thead>
        <tbody>
              <tr>
                <td>creature</td>
                <td>
                  src/cards/creature
                  
                </td>
                
            </tr>
            <tr>
                <td>instant</td>
                <td>
                  src/cards/Instant
                  
                </td>
                
            </tr>
            <tr>
                <td>land</td>
                <td>src/cards/land
                </td>
                
            </tr>
            <tr>
              <td>sorcery</td>
              <td>src/cards/sorcery
              </td>
              
            </tr>

        </tbody>

    </table>

      <h1>创建卡牌例子-Creature</h1>
      <h2>Creature-例子1</h2>
      如果想创建一个creature的卡牌，加入名字是Xuanpei,属性是7/2，法力值是3UU，传说稀有度，效果是选择一个创造物，获得+1+1，死亡后给一个随机友方创造物+1+1
      <pre><code class="lang-python">


from game.buffs import StateBuff

class Xuanpei(Creature):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Xuanpei"
        self.live:int=2
        self.power:int=7
        self.actual_live:int=2
        self.actual_power:int=7

        self.type_creature:str="Human"
        self.type:str="Creature"

        self.mana_cost:str="3UU"
        self.color:str="blue"
        self.type_card:str="Human"
        self.rarity:str="Mythic Rare"
        self.content:str="When Xuanpei enters the battlefield, select a creature and +1+1,when die randomly select your creature and +1+1"
        self.image_path:str="cards/creature/Xuanpei/image.jpg"
        
    @select_object("all_creatures",1)
    async def when_enter_battlefield(self, player: "Player" = None, opponent: "Player" = None,selected_object:tuple['Card']=()):# when creature enter battlefield
        if selected_object:
            buff=StateBuff(self,selected_object[0],1,1)
            selected_object[0].gain_buff(buff,self)

     async def when_die(self,player: "Player" = None, opponent: "Player" = None):#OK
        if player.battlefield:
            card=random.choice(player.battlefield)
            buff=StateBuff(self,card,1,1)
            card.gain_buff(buff,self)


      </code></pre>
      <h1>创建卡牌例子-Land</h1>
      <h2>Land-例子1</h2>
      如果想创建一张地牌，名字叫Ji，功能是当点击时，会抽一张牌，是蓝色
      <pre><code class="lang-python">
class Ji(Land):


    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Ji"

        self.type:str="Land"

        self.mana_cost:str=""
        self.color:str="blue"
        self.type_card:str="Land"
        self.rarity:str="Rare"
        self.content:str="it will draw a card instead of generate mana"
        self.image_path:str="cards/land/Elysian Grove/image.jpg"

    async def when_clicked(self,player:'Player'=None,opponent:'Player'=None):#当地牌被点击时横置，有一些是获得mana，有一些是别的能力   #启动式能力（Activated Abilities）：玩家可以在任何时候支付成本来使用的能力，通常格式为“[成本]：[效果]”。
        if not self.get_flag("tap"):
            player.draw_card(1)
            self.tap()
            return True
        else:
            return False
        </code></pre>
        <h2>Land-例子2</h2>
      如果想创建一张地牌，名字叫Ni，功能是当点击时，会产生3点黑色法力值,当进入场地时，对我方英雄造成3点伤害
      <pre><code class="lang-python">
class Ni(Land):


    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Ni"

        self.type:str="Land"

        self.mana_cost:str=""
        self.color:str="black"
        self.type_card:str="Land"
        self.rarity:str="Rare"
        self.content:str="generate 3 mana , when enter battlefield deal 3 damage to your player"
        self.image_path:str="cards/land/Elysian Grove/image.jpg"

    def generate_mana(self)->dict:
        return {"B":3}

    @select_object("",1)
    async def when_enter_battlefield(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):
        await self.attact_to_object(player,3,"rgba(0, 0, 0, 0.9)","Missile_Hit")
    
      </code></pre>
      <h1>创建卡牌例子-Sorcery</h1>
      <h2>Sorcery-例子1</h2>
      如果想做一个法术牌名字是Tai,法力是3G，是召唤两个树人，然后给每一个友方随从获得亡语，召唤一个树人可以这样做
      <pre><code class="lang-python">

from game.buffs import Buff
from game.type_cards.creature import Creature



class Tai_Summon_Die_Tree(Buff):
    def __init__(self,card:"Card",selected_card:"Card") -> None:
        super().__init__(card,selected_card)
        self.card=card#这个buff是属于哪一张卡的
        self.content:str="Summon one 1/1 tree"#描述buff
        self.buff_name=f"{card.name}"

    def change_function(self,card:"Creature"):
        previews_func=card.when_die
        async def when_die(self_card,player,opponent):
            await previews_func(player,opponent)
            creature_tree=Tai_Tree(card.player)
            player.append_card(creature_tree,"battlefield")
        card.when_die = types.MethodType(when_die, card)
    

class Tai(Sorcery):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Tai"

        self.type:str="Sorcery"

        self.mana_cost:str="3G"
        self.color:str="green"
        self.type_card:str="Sorcery"
        self.rarity:str="Uncommon"
        self.content:str="..."
        self.image_path:str="cards/sorcery/Angelic Blessing/image.jpg"
    @select_object("",1)
    async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):# when player use the card
        for i in range(2):
            creature_tree=Tai_Tree(self.player)
            player.append_card(creature_tree,"battlefield")
        for card in player.battlefield:
            buff=Tai_Summon_Die_Tree(self,card)
            card.gain_buff(buff,self)
        
    
class Tai_Tree(Creature):
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Tree man"
        self.live:int=1
        self.power:int=1
        self.actual_live:int=1
        self.actual_power:int=1

        self.type_creature:str="Creature"
        self.type:str="Creature"

        self.mana_cost:str="1"
        self.color:str="green"
        self.type_card:str="Creature"
        self.rarity:str="Uncommon"
        self.content:str=""
        self.image_path:str="cards/sorcery/Angelic Blessing/image.jpg"
    

      </code></pre>

      <!-- <h2>Sorcery-例子2</h2> -->
      
      <h1>创建卡牌例子-Instant</h1>
      <h2>Instant-例子1</h2>
      如果想做一个法术牌名字是Mei,法力是3W，选择，是为我方英雄回复10点血，还是祈祷10
      <pre><code class="lang-python">
class Mei(Instant):
    
    
    def __init__(self,player) -> None:
        super().__init__(player)

        self.name:str="Mei"

        self.type:str="Instant"

        self.mana_cost:str="3W"
        self.color:str="gold"
        self.type_card:str="Instant"
        self.rarity:str="Mythic Rare"
        self.content:str="..."
        self.image_path:str="cards/Instant/Arcane Inferno/image.jpg"

    @select_object("",1)
    async def card_ability(self,player:'Player'=None,opponent:'Player'=None,selected_object:tuple['Card']=()):
        if selected_object:
            if selected_object[0].content=="Cure 10":
                await self.cure_to_object(player,10,"rgba(255, 255, 255, 0.9)","Missile_Hit")
            elif selected_object[0].content=="Scry 10":
                await self.Scry(self,player,opponent,10):


    async def selection_step(self, player: "Player" = None, opponent: "Player" = None,selection_random:bool=False):
        selection1=self.create_selection("Cure 10",1)
        selection2=self.create_selection("Scry 10",2)

        card=await player.send_selection_cards([selection1,selection2],selection_random)
            
        return [card]

      </code></pre>
      <!-- <h2>Instant-例子2</h2> -->
















      














      



      







    





        





        
          
              
</div>
        





      
     

    </div>
    <script src="webpages/tech_doc/create_dir.js"></script>
    <script src="webpages/tech_doc/top_footer.js"></script>
    <script src="webpages/tech_doc/subtitle.js"></script>
    <script src="webpages/tech_doc/prism.js"></script>
    
</body>

</html>
